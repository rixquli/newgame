<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>World of Capitalist</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC"
      crossorigin="anonymous"
    />
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM"
      crossorigin="anonymous"
    ></script>

    <style>
      body {
        margin: 0;
        font-family: "Roboto", sans-serif;
        color: white;
      }
      #crosshair {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 2%;
        transform: translate(-50%, -50%);
      }
      #ammo_container {
        position: absolute;
        right: 5%;
        bottom: 5%;
        font-size: 3em;
      }
      #score_container {
        position: absolute;
        right: 5%;
        top: 5%;
        font-size: 3em;
      }
      #progress {
        position: absolute;
        bottom: 9%;
        left: 0;
        width: 0;
        height: 2%;
        background-color: white;
      }
      #health_container {
        position: absolute;
        bottom: 8%;
        left: 5%;
        width: 18%;
        height: 2%;
        border: 1px solid #ffffff;
      }
      #health_progress {
        position: absolute;
        background-color: #ffffff;
        width: 100%;
        height: 100%;
      }
      #game_hud {
        visibility: hidden;
      }
      #menu {
        position: absolute;
        width: 100%;
        height: 100%;
        background-image: url("/img/image_accueil_jeu.jpg");
        background-repeat: no-repeat;
        background-position: center;
        background-size: cover;
        text-align: center;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        visibility: hidden;
      }
      h1 {
        font-family: "Libre Barcode 39 Text", cursive;
        font-size: 4em;
      }
      button {
        background-color: rgba(0, 0, 0, 0);
        color: rgb(221, 221, 221);
        font-size: 1.5em;
        border: none;
        cursor: pointer;
        margin-top: 10%;
        font-weight: 700;
      }
      #debug {
        position: absolute;
        right: 5%;
        top: 5%;
      }
      #death_screen {
        position: absolute;
        width: 100%;
        height: 100%;
        background-color: black;
        opacity: 0.4;
        text-align: center;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        visibility: hidden;
      }
      #death_screen div {
        opacity: 1;
      }
      #right {
        border: #000;
        border-style: solid;
        margin: 5px;
      }
      #left {
        border: #000;
        border-style: solid;
        margin: 5px;
      }
      #selectMenu {
        color: black;
        position: absolute;
        width: 100%;
        height: 100%;
        background-color: rgb(0, 195, 255);
        text-align: center;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        visibility: hidden;
      }
      .joinParty {
        position: absolute;
        top: 0;
      }
      #partyList {
        width: 80%;
        background-color: wheat;
      }
      #info {
        position: fixed;
        top: 0;
        left: 0;
        background-color: aqua;
        z-index: 2;
        visibility: visible;
      }
      #gridSelector {
        position: fixed;
        visibility: hidden;
        right: 0;
        top: 12vh;
        background-color: chocolate;
        border-radius: 10px;
        height: 100%;
        max-width: 50vw;
      }
      #gridSelector > button {
        font-size: 1em;
      }
      div#collectMenu {
        display: none;
        height: 85%;
        overflow: scroll;
      }
      #buildMenu {
        display: flex;
        flex-direction: column;
        height: 85%;
        overflow: scroll;
      }
      #buildMenu > button {
        border: solid #000;
        border-radius: 10px;
      }
      #collectMenu > button {
        border: solid #000;
        border-radius: 10px;
      }
      .buildable {
        margin-top: 0.2em;
        margin-bottom: 0.2em;
      }
      #resources {
        position: fixed;
        display: flex;
        flex-direction: row;
        align-items: center;
        justify-content: center;
        z-index: 3;
        visibility: hidden;
        top: 0px;
        height: 10vh;
        gap: 50px;
        width: 100vw;
      }

      #resources div {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }

      .villagerList {
        margin: 5px;
        padding: 2px;
        border: solid black;
        border-radius: 10px;
      }
      input.color {
        visibility: hidden;
      }
      img.villagerColor {
        width: 20%;
        position: absolute;
      }
      .jobButton {
        font-size: 1.5em;
        line-height: 0.8em;
      }
      .job {
        font-size: 0.6em;
        margin-bottom: 10px;
      }
      .houseNumber {
        font-size: 1.7em;
      }

      #error {
        position: fixed;
        bottom: 0;
        color: red;
      }
      .loadingScreen {
        visibility: hidden;
        position: fixed;
        display: flex;
        flex-direction: column-reverse;
        align-items: center;
        height: 100vh;
        width: 100%;
        background-color: black;
        z-index: 10;
      }

      #loadingScreen {
        width: 100vw;
      }
      .joystick {
        visibility: hidden;
        position: absolute;
      }
      canvas#joystick {
        position: fixed;
        bottom: 10px;
      }
      button.startJoinGame {
        color: cornflowerblue;
        margin: 0;
      }
      div#partyList {
        gap: 10px;
        display: flex;
        flex-direction: column;
        border-radius: 10px;
      }
      .party {
        border: solid;
        border-radius: 10px;
        gap: 10px;
      }
      .form-row {
        display: flex;
        flex-wrap: wrap;
        margin-right: -5px;
        margin-left: -5px;
      }
    </style>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
      }
    </style>

    <!--script
      async
      src="https://ga.jspm.io/npm:es-module-shims@1.5.17/dist/es-module-shims.js"
    ></script-->

    <script
      defer
      src="https://cdn.jsdelivr.net/gh/kripken/ammo.js@HEAD/builds/ammo.js"
    ></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/3.0.5/seedrandom.min.js"></script>
    <!--script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.141.0/build/three.module.js"
        }
      }
    </script-->
    <script src="/socket.io/socket.io.js"></script>

    <!-- <script
    type="text/javascript"
    src="/node_modules/physijs/src/physi.js"
  ></script> -->
    <script type="module">
      //import * as THREE from "three";

      import * as THREE from "https://unpkg.com/three@0.141.0/build/three.module.js";
      //from "https://cdn.jsdelivr.net/npm/three@0.118/build/three.module.js";

      // import { OrbitControls } from "https://unpkg.com/three@0.141.0/examples/jsm/controls/OrbitControls.js";
      // import { OrbitControls } from "https://unpkg.com/three@0.141.0/examples/fonts/helvetiker_regular.typeface.json";
      // import Stats from "./jsm/libs/stats.module.js";

      import { GLTFLoader } from "/js/GLTFLoader.js";

      import { FBXLoader } from "/js/FBXLoader.js";
      import { FontLoader } from "/js/FontLoader.js";
      import { TextGeometry } from "/js/TextGeometry.js";
      //import * as HOUSE from "/structure/house/01_medieval_house_low_poly.glb"
      //https://unpkg.com/three@0.141.0/examples/jsm/geometries/TextGeometry.js
      //https://unpkg.com/three@0.141.0/examples/jsm/curves/NURBSUtils.js

      //import { Pathfinding } from 'https://unpkg.com/three-pathfinding@1.1.0/src/index.js';

      //import randomP from "/random.json"
      const randomP = [
        {
          houseVillager: 0.1,
          stone: 1.1,
          farmWithoutWheat: 3,
          farmWithWheat: 10,
          wood: 5,
        },
      ];

      // import bos from "/character.gltf";

      // import { Octree } from "https://unpkg.com/three@0.141.0/examples//jsm/math/Octree.js";
      // import { OctreeHelper } from "https://unpkg.com/three@0.141.0/examples//jsm/helpers/OctreeHelper.js";

      // import { Capsule } from "https://unpkg.com/three@0.141.0/examples//jsm/math/Capsule.js";

      // import { GUI } from "https://unpkg.com/three@0.141.0/examples//jsm/libs/lil-gui.module.min.js";

      ////import Ammo from "/js/ammo.js";

      //import { annuaire } from "/annuaire.js";
      class otherPlayer {
        constructor() {
          this.clock = new THREE.Clock();
          this.mixer = [];
          this.animationActions = [];
          this.init();
        }
        init() {}

        CreatePlayerAnimation(anim, player) {
          let index = this.mixer.length || 0
          this.mixer[index] = new THREE.AnimationMixer(player);
          console.log(this.mixer[index].getRoot());
          console.log(player);
          console.log(player==this.mixer[index].getRoot());
          // console.log(fbx);
          if (anim[0]) {
            const animationAction = this.mixer[
            index
            ].clipAction(anim[1]);
            animationAction.play();
            this.activeAction = animationAction;
            this.animationActions[index]=[]
            this.animationActions[index]["root"]=this.mixer[index].getRoot().id
            this.animationActions[index]["Idle"] = this.mixer[
            index
            ].clipAction(anim[0]);
            this.animationActions[index]["run"] = this.mixer[
            index
            ].clipAction(anim[1]);
            console.log(this.animationActions);
          }
        }
        update() {
          let delta = this.clock.getDelta();
          for (let i = 0; i < this.mixer.length; i++) {
            if (this.mixer[i]) {
              this.mixer[i].update(delta);
            }
          }
        }
        movePlayers() {
          this.setAction(action);
        }
        setAction(action, id) {
          // toAction.play();
          if(action=="Run") action = "run"
          //console.log(this.animationActions);
          //console.log(this.animationActions.find((e)=>e.root==id));
          let toAction = this.animationActions.find((e)=>e.root==id)[action];
          //console.log(this.animationActions.find((e)=>e.root==id)[action]);
          if (toAction != this.activeAction && toAction != undefined) {
            //console.log(toAction);
            this.lastAction = this.activeAction;
            this.activeAction = toAction;
            //lastAction.stop()
            this.lastAction.fadeOut(0.5);
            toAction.reset();
            toAction.fadeIn(0.5);
            toAction.play();
            console.log("toAction.isRunning()")
          }
        }
        deletePlayer(id) {
          console.log(id);
        }
      }
      class Color {
        constructor(r, g, b) {
          this.set(r, g, b);
        }

        toString() {
          return `rgb(${Math.round(this.r)}, ${Math.round(
            this.g
          )}, ${Math.round(this.b)})`;
        }

        set(r, g, b) {
          this.r = this.clamp(r);
          this.g = this.clamp(g);
          this.b = this.clamp(b);
        }

        hueRotate(angle = 0) {
          angle = (angle / 180) * Math.PI;
          const sin = Math.sin(angle);
          const cos = Math.cos(angle);

          this.multiply([
            0.213 + cos * 0.787 - sin * 0.213,
            0.715 - cos * 0.715 - sin * 0.715,
            0.072 - cos * 0.072 + sin * 0.928,
            0.213 - cos * 0.213 + sin * 0.143,
            0.715 + cos * 0.285 + sin * 0.14,
            0.072 - cos * 0.072 - sin * 0.283,
            0.213 - cos * 0.213 - sin * 0.787,
            0.715 - cos * 0.715 + sin * 0.715,
            0.072 + cos * 0.928 + sin * 0.072,
          ]);
        }

        grayscale(value = 1) {
          this.multiply([
            0.2126 + 0.7874 * (1 - value),
            0.7152 - 0.7152 * (1 - value),
            0.0722 - 0.0722 * (1 - value),
            0.2126 - 0.2126 * (1 - value),
            0.7152 + 0.2848 * (1 - value),
            0.0722 - 0.0722 * (1 - value),
            0.2126 - 0.2126 * (1 - value),
            0.7152 - 0.7152 * (1 - value),
            0.0722 + 0.9278 * (1 - value),
          ]);
        }

        sepia(value = 1) {
          this.multiply([
            0.393 + 0.607 * (1 - value),
            0.769 - 0.769 * (1 - value),
            0.189 - 0.189 * (1 - value),
            0.349 - 0.349 * (1 - value),
            0.686 + 0.314 * (1 - value),
            0.168 - 0.168 * (1 - value),
            0.272 - 0.272 * (1 - value),
            0.534 - 0.534 * (1 - value),
            0.131 + 0.869 * (1 - value),
          ]);
        }

        saturate(value = 1) {
          this.multiply([
            0.213 + 0.787 * value,
            0.715 - 0.715 * value,
            0.072 - 0.072 * value,
            0.213 - 0.213 * value,
            0.715 + 0.285 * value,
            0.072 - 0.072 * value,
            0.213 - 0.213 * value,
            0.715 - 0.715 * value,
            0.072 + 0.928 * value,
          ]);
        }

        multiply(matrix) {
          const newR = this.clamp(
            this.r * matrix[0] + this.g * matrix[1] + this.b * matrix[2]
          );
          const newG = this.clamp(
            this.r * matrix[3] + this.g * matrix[4] + this.b * matrix[5]
          );
          const newB = this.clamp(
            this.r * matrix[6] + this.g * matrix[7] + this.b * matrix[8]
          );
          this.r = newR;
          this.g = newG;
          this.b = newB;
        }

        brightness(value = 1) {
          this.linear(value);
        }
        contrast(value = 1) {
          this.linear(value, -(0.5 * value) + 0.5);
        }

        linear(slope = 1, intercept = 0) {
          this.r = this.clamp(this.r * slope + intercept * 255);
          this.g = this.clamp(this.g * slope + intercept * 255);
          this.b = this.clamp(this.b * slope + intercept * 255);
        }

        invert(value = 1) {
          this.r = this.clamp((value + (this.r / 255) * (1 - 2 * value)) * 255);
          this.g = this.clamp((value + (this.g / 255) * (1 - 2 * value)) * 255);
          this.b = this.clamp((value + (this.b / 255) * (1 - 2 * value)) * 255);
        }

        hsl() {
          // Code taken from https://stackoverflow.com/a/9493060/2688027, licensed under CC BY-SA.
          const r = this.r / 255;
          const g = this.g / 255;
          const b = this.b / 255;
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          let h,
            s,
            l = (max + min) / 2;

          if (max === min) {
            h = s = 0;
          } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
              case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;

              case g:
                h = (b - r) / d + 2;
                break;

              case b:
                h = (r - g) / d + 4;
                break;
            }
            h /= 6;
          }

          return {
            h: h * 100,
            s: s * 100,
            l: l * 100,
          };
        }

        clamp(value) {
          if (value > 255) {
            value = 255;
          } else if (value < 0) {
            value = 0;
          }
          return value;
        }
      }

      class Solver {
        constructor(target, baseColor) {
          this.target = target;
          this.targetHSL = target.hsl();
          this.reusedColor = new Color(0, 0, 0);
        }

        solve() {
          const result = this.solveNarrow(this.solveWide());
          return {
            values: result.values,
            loss: result.loss,
            filter: this.css(result.values),
          };
        }

        solveWide() {
          const A = 5;
          const c = 15;
          const a = [60, 180, 18000, 600, 1.2, 1.2];

          let best = { loss: Infinity };
          for (let i = 0; best.loss > 25 && i < 3; i++) {
            const initial = [50, 20, 3750, 50, 100, 100];
            const result = this.spsa(A, a, c, initial, 1000);
            if (result.loss < best.loss) {
              best = result;
            }
          }
          return best;
        }

        solveNarrow(wide) {
          const A = wide.loss;
          const c = 2;
          const A1 = A + 1;
          const a = [0.25 * A1, 0.25 * A1, A1, 0.25 * A1, 0.2 * A1, 0.2 * A1];
          return this.spsa(A, a, c, wide.values, 500);
        }

        spsa(A, a, c, values, iters) {
          const alpha = 1;
          const gamma = 0.16666666666666666;

          let best = null;
          let bestLoss = Infinity;
          const deltas = new Array(6);
          const highArgs = new Array(6);
          const lowArgs = new Array(6);

          for (let k = 0; k < iters; k++) {
            const ck = c / Math.pow(k + 1, gamma);
            for (let i = 0; i < 6; i++) {
              deltas[i] = Math.random() > 0.5 ? 1 : -1;
              highArgs[i] = values[i] + ck * deltas[i];
              lowArgs[i] = values[i] - ck * deltas[i];
            }

            const lossDiff = this.loss(highArgs) - this.loss(lowArgs);
            for (let i = 0; i < 6; i++) {
              const g = (lossDiff / (2 * ck)) * deltas[i];
              const ak = a[i] / Math.pow(A + k + 1, alpha);
              values[i] = fix(values[i] - ak * g, i);
            }

            const loss = this.loss(values);
            if (loss < bestLoss) {
              best = values.slice(0);
              bestLoss = loss;
            }
          }
          return { values: best, loss: bestLoss };

          function fix(value, idx) {
            let max = 100;
            if (idx === 2 /* saturate */) {
              max = 7500;
            } else if (idx === 4 /* brightness */ || idx === 5 /* contrast */) {
              max = 200;
            }

            if (idx === 3 /* hue-rotate */) {
              if (value > max) {
                value %= max;
              } else if (value < 0) {
                value = max + (value % max);
              }
            } else if (value < 0) {
              value = 0;
            } else if (value > max) {
              value = max;
            }
            return value;
          }
        }

        loss(filters) {
          // Argument is array of percentages.
          const color = this.reusedColor;
          color.set(0, 0, 0);

          color.invert(filters[0] / 100);
          color.sepia(filters[1] / 100);
          color.saturate(filters[2] / 100);
          color.hueRotate(filters[3] * 3.6);
          color.brightness(filters[4] / 100);
          color.contrast(filters[5] / 100);

          const colorHSL = color.hsl();
          return (
            Math.abs(color.r - this.target.r) +
            Math.abs(color.g - this.target.g) +
            Math.abs(color.b - this.target.b) +
            Math.abs(colorHSL.h - this.targetHSL.h) +
            Math.abs(colorHSL.s - this.targetHSL.s) +
            Math.abs(colorHSL.l - this.targetHSL.l)
          );
        }

        css(filters) {
          function fmt(idx, multiplier = 1) {
            return Math.round(filters[idx] * multiplier);
          }
          return `filter: invert(${fmt(0)}%) sepia(${fmt(1)}%) saturate(${fmt(
            2
          )}%) hue-rotate(${fmt(3, 3.6)}deg) brightness(${fmt(
            4
          )}%) contrast(${fmt(5)}%);`;
        }
      }

      function hexToRgb(hex) {
        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
        const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, (m, r, g, b) => {
          return r + r + g + g + b + b;
        });

        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result
          ? [
              parseInt(result[1], 16),
              parseInt(result[2], 16),
              parseInt(result[3], 16),
            ]
          : null;
      }

      class TimerResource {
        constructor(obj, scene) {
          this.obj = obj;
          this.prop = obj.prop;
          this.timer = 0;
          this.scene = scene;
          this.fontLoader = new FontLoader();

          this.setTimer();
        }

        setTimer() {
          if (this.prop == "stone") this.addTimer(5);
          else if (this.prop == "wheat") this.addTimer(2);
          else if (this.prop == "wood") this.addTimer(5);
        }

        addTimer(time) {
          this.obj.collectable = false;
          this.fontLoader.load(
            "https://unpkg.com/three@0.141.0/examples/fonts/helvetiker_regular.typeface.json",
            (font) => {
              const geometry = new TextGeometry("00:0" + time, {
                font: font,
                size: 5,
                height: 5,
                //curveSegments: 12,
                //bevelEnabled: true,
                //bevelThickness: 10,
                //bevelSize: 8,
                //bevelOffset: 0,
                //bevelSegments: 5,
              });

              let text = new THREE.Mesh(
                geometry,
                new THREE.MeshPhongMaterial({ color: 0x3e00cf })
              );
              text.position.set(
                this.obj.position.x - 10,
                this.obj.position.y + 10,
                this.obj.position.z
              );
              text.time = time;
              this.scene.add(text);
              text.name = text.id;
              this.updateTimer(time, text.id);
            }
          );
        }

        updateTimer(time, id) {
          this.currentId = id;
          let interval = setInterval(() => {
            if (!this.scene.getObjectByName(this.currentId)) return;
            if (Number(this.scene.getObjectByName(this.currentId).time) != 0) {
              let newTimeProp =
                Number(this.scene.getObjectByName(this.currentId).time) - 1;
              let position = {
                  x: this.scene.getObjectByName(this.currentId).position.x,
                  y: this.scene.getObjectByName(this.currentId).position.y,
                  z: this.scene.getObjectByName(this.currentId).position.z,
                },
                newId = this.scene.getObjectByName(this.currentId).id;
              this.scene.remove(this.scene.getObjectByName(this.currentId));
              this.createtext(
                newTimeProp,
                position.x,
                position.y,
                position.z,
                newId
              );
            } else {
              this.obj.collectable = true;
              this.scene.remove(this.scene.getObjectByName(this.currentId));
              console.log("you can collect");
              clearInterval(interval);
            }
          }, 1000);
        }

        createtext(time, x, y, z, id) {
          this.fontLoader.load(
            "https://unpkg.com/three@0.141.0/examples/fonts/helvetiker_regular.typeface.json",
            (font) => {
              const geometry = new TextGeometry("00:0" + time, {
                font: font,
                size: 5,
                height: 5,
                //curveSegments: 12,
                //bevelEnabled: true,
                //bevelThickness: 10,
                //bevelSize: 8,
                //bevelOffset: 0,
                //bevelSegments: 5,
              });

              let text = new THREE.Mesh(
                geometry,
                new THREE.MeshPhongMaterial({ color: 0x3e00cf })
              );
              text.position.set(x, y, z);
              text.name = id;
              text.time = time;
              this.scene.add(text);
              return (this.currentId = text.name);
            }
          );
        }
      }

      //class ShowResources {
      //  constructor() {
      //
      //  }
      //}

      class Villager {
        constructor(scene, loader) {
          this.scene = scene;
          this.FBXLoader = new FBXLoader();
          this.mixer = [];
          this.villagers = [];
          this.villagerActions = [];
          this.clock = new THREE.Clock();
          this.villagerSpeed = 0.2;
          this.activeAction = [];
          this.lastAction = [];
          //this.id = id
          //this.villager = this.villagers[id]
          //this.createVillager(position, house);
        }
        createVillager(position, house) {
          console.log(...position);
          this.houseN = house;
          for (let i = 1; i < 4; i++) {
            this.FBXLoader.load(
              "/character/stickman/source/Simple_Character.fbx",
              (fbx) => {
                this.villagers[house + "." + i] = fbx;
                console.log(position);
                this.villagers[house + "." + i].position.set(...position);
                this.villagers[house + "." + i].scale.set(0.03, 0.03, 0.03);
                this.villagers[house + "." + i].house = house;
                this.villagers[house + "." + i].job = "Is not working";
                this.villagers[house + "." + i].housePos = position;

                this.villagers[house + "." + i].stay = false;
                this.villagers[house + "." + i].returnHouse = false;

                let new_mtl = new THREE.MeshBasicMaterial({
                  color: 0x000000,
                });

                this.villagers[house + "." + i].traverse((o) => {
                  o.material = new_mtl;
                });

                this.mixer[house + "." + i] = new THREE.AnimationMixer(fbx);

                if (fbx.animations[0]) {
                  const animationAction = this.mixer[
                    house + "." + i
                  ].clipAction(fbx.animations[1]);
                  //animationAction.play();
                  this.activeAction[house + "." + i] = animationAction;
                  this.villagerActions[house + "." + i] = [];
                  this.villagerActions[house + "." + i]["idle"] = this.mixer[
                    house + "." + i
                  ].clipAction(fbx.animations[2]);
                  this.villagerActions[house + "." + i]["run"] = this.mixer[
                    house + "." + i
                  ].clipAction(fbx.animations[0]);
                }
                this.scene.add(this.villagers[house + "." + i]);
              },
              undefined,
              (error) => {
                console.error(error);
              }
            );
            setTimeout(() => {
              this.modelReady = true;
              console.log(this.villagerActions);
              console.log("model ready");
            }, 500);
          }
          this.addVillagerMenu();
        }
        addVillagerMenu() {
          if (this.houseN == 1) return;
          if (document.querySelector("#noVillagerText")?.style) {
            document.querySelector("#noVillagerText").style.visibility =
              "hidden";
          }
          let workerList = "";
          for (let i = 1; i < this.houseN; i++) {
            console.log(i);
            workerList =
              workerList +
              `<dl class="villagerList">
              <dt class="houseNumber">House n°${i}</dt>
              <dd class="villagerName">
                <label>
                  <img class="villagerColor" src="/img/pngegg.png">
                <input villagerid="${
                  i + ".1"
                }" class="color" type="color" name="colorPicker">
            </label>
            <button villagerid="${i + ".1"}" class="jobButton">Villageois ${i}.1
            <br/>
            <div villagerid="${i + ".1"}" class="job">${
                this.villagers[i + ".1"].job
              }</div>
            </button>
            </dd>
            <dd class="villagerName">
              <label>
                    <img class="villagerColor" src="/img/pngegg.png">
                  <input villagerid="${
                    i + ".2"
                  }" class="color" type="color" name="colorPicker">
              </label>
              <button villagerid="${
                i + ".2"
              }" class="jobButton">Villageois ${i}.2<br/>
            <div villagerid="${i + ".2"}" class="job">${
                this.villagers[i + ".2"].job
              }</div>
            </button>
            </dd>
            <dd class="villagerName">
              <label>
                  <img class="villagerColor" src="/img/pngegg.png">
                <input villagerid="${
                  i + ".3"
                }" class="color" type="color" name="colorPicker">
            </label>
              <button villagerid="${
                i + ".3"
              }" class="jobButton">Villageois ${i}.3<br/>
            <div villagerid="${i + ".3"}" class="job">${
                this.villagers[i + ".3"].job
              }
              </div>
              </button>
              </dd>
              </dl>`;
          }
          //this.addColorPicker();

          document.querySelector("#collectMenu").innerHTML = workerList;
          let colorWell = document.querySelectorAll(".color");
          colorWell.forEach((e) => {
            e.removeEventListener("change", (e) => this.updateColor(e), false);
          });
          colorWell.forEach((e) => {
            e.addEventListener("change", (e) => this.updateColor(e), false);
          });
          //colorWell.select();
          document.querySelectorAll(".jobButton").forEach((e) => {
            e.removeEventListener("click", (e) => this.doJob(e), false);
          });
          document.querySelectorAll(".jobButton").forEach((e) => {
            e.addEventListener("click", (e) => this.doJob(e), false);
          });
        }

        updateColor(e) {
          console.log(e.target.value);
          const rgb = hexToRgb(e.target.value);
          console.log(rgb);
          if (rgb.length !== 3) {
            alert("Invalid format!");
            return;
          }

          const color = new Color(rgb[0], rgb[1], rgb[2]);
          const solver = new Solver(color);
          const result = solver.solve();
          e.path[1].children[0].style = result.filter;
          console.log(result);
          let new_mtl = new THREE.MeshBasicMaterial({
            color: new THREE.Color(
              parseInt(e.target.value.replace("#", "0x"), 16)
            ),
          });

          this.villagers[e.target.getAttribute("villagerid")].traverse((o) => {
            o.material = new_mtl;
          });
        }

        //addColorPicker() {
        //  this.pickr = Pickr.create({
        //    el: ".color-picker",
        //    theme: "classic", // or 'monolith', or 'nano'
        //
        //    swatches: [
        //      "rgba(244, 67, 54, 1)",
        //      "rgba(233, 30, 99, 0.95)",
        //      "rgba(156, 39, 176, 0.9)",
        //      "rgba(103, 58, 183, 0.85)",
        //      "rgba(63, 81, 181, 0.8)",
        //      "rgba(33, 150, 243, 0.75)",
        //      "rgba(3, 169, 244, 0.7)",
        //      "rgba(0, 188, 212, 0.7)",
        //      "rgba(0, 150, 136, 0.75)",
        //      "rgba(76, 175, 80, 0.8)",
        //      "rgba(139, 195, 74, 0.85)",
        //      "rgba(205, 220, 57, 0.9)",
        //      "rgba(255, 235, 59, 0.95)",
        //      "rgba(255, 193, 7, 1)",
        //    ],
        //
        //    components: {
        //      // Main components
        //      preview: true,
        //      opacity: true,
        //      hue: true,
        //
        //      // Input / output Options
        //      interaction: {
        //        hex: true,
        //        rgba: true,
        //        hsla: true,
        //        hsva: true,
        //        cmyk: true,
        //        input: true,
        //        clear: true,
        //        save: true,
        //      },
        //    },
        //  });
        //  this.pickr.on("save", (color, instance) => {
        //    console.log('Event: "save"', color, instance);
        //  });
        //}

        doJob(e) {
          this.villagers[e.target.getAttribute("villagerid")].job = `from ${
            this.scene.getObjectByName("click").prop
          } at ${this.scene.getObjectByName("click").position.x / 20}, ${
            this.scene.getObjectByName("click").position.z / 20
          } to House  n°${e.target.getAttribute("villagerid").split(".")[0]}`;
          this.villagers[e.target.getAttribute("villagerid")].collectTarget = [
            this.scene.getObjectByName("click").position.x,
            -25,
            this.scene.getObjectByName("click").position.z,
          ];
          this.villagers[e.target.getAttribute("villagerid")].jobType =
            this.scene.getObjectByName("click").prop;

          this.addVillagerMenu();
        }

        returnToHouse(id) {
          this.villagers[id].returnHouse = true;
          this.villagers[id].stay = false;
        }

        villagerStay(id) {
          let type = this.villagers[id].jobType;
          if (this.villagers[id].returnHouse) {
          }
          if (type == "wood") {
            setTimeout(() => {
              this.returnToHouse(id);
            }, 1500);
          } else if (type == "stone") {
            setTimeout(() => {
              this.returnToHouse(id);
            }, 3000);
          }
        }

        moveVillagers(id, target) {
          //this.setAction(this.villagerActions[0]);
          if (!this.villagers[id]?.job) return;
          if (this.villagers[id].job == "Is not working") return;
          let directionX = 0,
            directionZ = 0;

          let mesh1 = {
            x: this.villagers[id].position.x,
            z: this.villagers[id].position.z,
          };
          let mesh2 = {
            x: target[0],
            z: target[2],
          };

          var dx = Math.abs(mesh1.x - mesh2.x);
          if (mesh1.x > mesh2.x) {
            this.villagers[id].position.x -= Math.min(dx, this.villagerSpeed);
            directionX = -90;
          } else if (mesh1.x < mesh2.x) {
            this.villagers[id].position.x += Math.min(dx, this.villagerSpeed);
            directionX = 90;
          }

          var dz = Math.abs(mesh1.z - mesh2.z);
          if (mesh1.z > mesh2.z) {
            this.villagers[id].position.z -= Math.min(dz, this.villagerSpeed);
            directionZ = 180;
          } else if (mesh1.z < mesh2.z) {
            this.villagers[id].position.z += Math.min(dz, this.villagerSpeed);
            directionZ = 0;
          }

          if (mesh1.x == mesh2.x && mesh1.z == mesh2.z) {
            if (
              this.villagers[id].stay == false ||
              this.villagers[id].stay == undefined
            ) {
              this.villagers[id].stay = true;
              //this.villagerStay(id);
            }
            this.setAction(this.villagerActions[id]["idle"], id);
          } else {
            //console.log((directionX + directionZ) / 2);
            if (this.villagers[id].returnHouse) {
              this.villagers[id].lookAt(...this.villagers[id].housePos);
              //this.villagers[id].rotation.x = 0;
              //this.villagers[id].rotation.z = 0;
              //this.villagers[id].rotation.y =
              //  ((((directionX + directionZ) / 2) * Math.PI) / 180) * -1;
            } else {
              this.villagers[id].lookAt(...this.villagers[id].collectTarget);
              //this.villagers[id].rotation.x = 0;
              //this.villagers[id].rotation.z = 0;
              //this.villagers[id].rotation.y =
              //  (((directionX + directionZ) / 2) * Math.PI) / 180;
            }

            this.setAction(this.villagerActions[id]["run"], id);
          }
        }

        //startTimer(id) {
        //  this.time = 0;
        //  this.time = setInterval(() => {
        //    if (this.villagers[id].stay == true) return;
        //    this.time += 100;
        //  }, 100);
        //
        //}

        work() {
          if (this.houseN == 1) return;
          for (let i = 1; i < this.houseN; i++) {
            for (let j = 1; j < 4; j++) {
              //this.setAction(this.villagerActions[0]);
              if (!this.villagers[i + "." + j]?.job) return;
              //if (this.villagers[i + "." + j].job == "Is not working") return

              if (
                this.villagers[i + "." + j].stay == true &&
                !this.villagers[i + "." + j].returnHouse
              ) {
                this.villagerStay(i + "." + j);
              }
              if (
                !this.villagers[i + "." + j].returnHouse &&
                !this.villagers[i + "." + j].stay
              ) {
                this.moveVillagers(
                  i + "." + j,
                  this.villagers[i + "." + j].collectTarget
                );
                //if (!this.startingTimer) {
                //  this.startingTimer = true;
                //  this.startTimer(i + "." + j);
                //}
              }
              if (
                this.villagers[i + "." + j].returnHouse == true &&
                !this.villagers[i + "." + j].stay
              ) {
                this.moveVillagers(
                  i + "." + j,
                  this.villagers[i + "." + j].housePos
                );
              }
              if (
                this.villagers[i + "." + j].returnHouse == true &&
                this.villagers[i + "." + j].stay == true
              ) {
                this.addResources(this.villagers[i + "." + j].jobType, 5);
                this.villagers[i + "." + j].returnHouse = false;
                this.villagers[i + "." + j].stay = false;
              }
            }
          }
        }

        addResources(value, nbr) {
          if (!document.querySelector(`#${value}Count`)?.textContent) return;
          document.querySelector(`#${value}Count`).textContent =
            Number(document.querySelector(`#${value}Count`).textContent) + nbr;
        }

        setAction(toAction, id) {
          // toAction.play();
          if (toAction != this.activeAction[id] && toAction != undefined) {
            //console.log(toAction);
            this.lastAction[id] = this.activeAction[id];
            this.activeAction[id] = toAction;
            //lastAction.stop()
            this.lastAction[id].fadeOut(1);
            toAction.reset();
            toAction.fadeIn(1);
            toAction.play();
          }
        }

        update() {
          this.delta = this.clock.getDelta();

          if (this.mixer && this.modelReady == true) {
            for (let i = 1; i < this.houseN; i++) {
              if (!this.mixer[i + ".3"]) return;
              this.mixer[i + ".1"].update(this.delta);
              this.mixer[i + ".2"].update(this.delta);
              this.mixer[i + ".3"].update(this.delta);
            }
            //for (const e of this.mixer) {
            //  e.update(this.delta)
            //}
            //this.mixer.forEach((e) => {
            //  e.update(this.delta);
            //});
            //this.animationActions[0].play()
            //console.log(this.villagers["1.1"]);
            //console.log(this.villagerActions[0].isRunning());
            //this.mixer["1.1"].update(this.delta);
            //this.mixer.update(this.delta);
          }
          //console.log(this.player.position);

          this.work();
          //this.moveVillagers();
        }
      }

      class App {
        constructor() {
          this.socket = io();
          //this.socket.on("pos", (d) => (console.log(d)));
          this.clock = new THREE.Clock();
          this.STEPS_PER_FRAME = 5;
          this.GRAVITY = -7.5;

          this.rigidBodies = [];
          this.currentPosition = new THREE.Vector3();
          this.currentLookat = new THREE.Vector3();

          this.assets = [];
          //this.zombieAnims = [];
          // this.tempTransform = null;

          // keyboard controls
          this.speed = 0.5;
          this._keys = {
            moveForward: false,
            moveBackward: false,
            moveLeft: false,
            moveRight: false,
            space: false,
            shift: false,
          };

          this.rotationView = -1;

          this.tempVec = new THREE.Vector3();

          this.player = null;
          this.playerIsLoading = false;
          // moveDirection = { left: 0, right: 0, forward: 0, back: 0 };
          this.STATE = { DISABLE_DEACTIVATION: 4 };

          this.mouse = new THREE.Vector2();
          this.clickableObjs = [];
          this.raycaster = new THREE.Raycaster();
          this.randomP = randomP[0];
          this.previousFrame = null;

          this.isMouseHover = false;

          this.canCollect = false;

          this.modelReady = false;

          this.players = {};
          this.mainPlayer = null;

          this.animationActions = [];

          this.activeAction;
          this.villagers = [];

          this.houseN = 1;

          this.villagerSpeed = 0.4;
          this.villagerActions = [];
          this.mixer = [];

          this.rotationCanvas = 0;
          this.rotationCanvasEnable = false;

          this.seed = 69;
          this.mapSize = { x: 20, z: 20 };

          this.playerLastPosition = new THREE.Vector3();
          this.playersAnim = new otherPlayer();

          this.playerRotation = -1;
          this.socket.on("partyList", (data) => {
            this.partyList = data.map((e) => {
              return e.slice(6);
            });
          });
          this.socket.on("structure", (d) => {
            console.log(Object.keys(d).map((_) => d[_]));
            let structure = Object.keys(d).map((_) => d[_]);

            this.loadStructure(...structure);
          });

          this.init();
          // this.createRender();
          // this.keyboardControls();
          // this.startAmmo();
          // this.update();
        }

        init() {
          this.createRender();
          this.eventResize();
          // this.load();
          this.createLight();
          //this.loadBackground();
          this.SetupStartButton();
          // this.keyboardControls();

          // this.startAmmo();
          // this.update();
          this.ShowMenu();
        }

        SetupStartButton() {
          document
            .getElementById("start_game")
            .addEventListener("click", () => this.showSelectMenu());
        }

        StartGame = () => {
          window.cancelAnimationFrame(this.update);

          //Create entities and physics
          // this.scene.clear();
          this.Villagers = new Villager(this.scene, this.FBXLoader);
          this.addEvent();

          this.keyboardControls();
          this.mouseControls();
          this.createAmmo();
          //this.createPathfinding()
          document.querySelector("#resources").style.visibility = "visible";
          //this.showResources();
          //this.animFrameId = window.requestAnimationFrame(this.update);
          this.update();
          //if (document.getElementById("Ipad").checked == true) {
          //  this.SetupTactileButton();
          //}
          // this.ShowMenu(false);
          //Set
        };

        //createPathfinding() {
        //  this.pathfinding = new Pathfinding()
        //  this.zone = "world"
        //  this.pathfinding.setZoneData(this.zone, Pathfinding.createZone())
        //}

        addEvent() {
          //e,unit, unitN,path,x,y,z,scale,house,rotaion
          document
            .querySelector("#showBuildMenu")
            .addEventListener("click", (e) => this.toggleMenu(e), false);
          document
            .querySelector("#showCollectMenu")
            .addEventListener("click", (e) => this.toggleMenu(e), false);
          //document
          //  .querySelector("#buildHouse")
          //  .addEventListener("click", (e) => this.buildHouse(e), false);
          document
            .querySelector("#buildHouse")
            .addEventListener(
              "click",
              (e) =>
                this.buildStructure(
                  e,
                  "wood",
                  50,
                  "house/01_medieval_house_low_poly.glb",
                  0,
                  -23,
                  0,
                  2,
                  true,
                  Math.PI / 2,
                  "house"
                ),
              false
            );
          document
            .querySelector("#buildMine")
            .addEventListener(
              "click",
              (e) =>
                this.buildStructure(
                  e,
                  "stone",
                  50,
                  "low-poly_mine/scene.gltf",
                  0.5,
                  -28,
                  0.5,
                  1,
                  false,
                  -Math.PI / 2,
                  "mine"
                ),
              false
            );
          document
            .querySelector("#buildBlacksmithHouse")
            .addEventListener(
              "click",
              (e) =>
                this.buildStructure(
                  e,
                  "stone",
                  50,
                  "blacksmiths_house/scene.gltf",
                  2,
                  -28,
                  0,
                  0.1,
                  false,
                  Math.PI / 2,
                  "blacksmithHouse"
                ),
              false
            );
          document
            .querySelector("#buildShop")
            .addEventListener(
              "click",
              (e) =>
                this.buildStructure(
                  e,
                  "stone",
                  50,
                  "small_store/scene.gltf",
                  0,
                  -28,
                  0,
                  0.23,
                  false,
                  0,
                  "shop"
                ),
              false
            );
          //document
          //  .querySelector("#buildMine")
          //  .addEventListener("click", (e) => this.buildMine(e), false);
          //document
          //  .querySelector("#buildBlacksmithHouse")
          //  .addEventListener(
          //    "click",
          //    (e) => this.buildBlacksmithHouse(e),
          //    false
          //  );
          //document
          //  .querySelector("#buildShop")
          //  .addEventListener("click", (e) => this.buildShop(e), false);
        }

        toggleMenu(e) {
          e.stopPropagation();
          e.preventDefault();
          $("#buildMenu").toggle();
          $("#collectMenu").toggle();
        }

        // loadCharacter = () => {
        //   console.log("e");
        // };

        //load(path) {
        //  this.animationActions = [];
        //
        //  this.activeAction;
        //  this.loader.load(
        //    path,
        //    (fbx) => {
        //      console.log(fbx);
        //      this.player = this.player = fbx;
        //      this.player.rotation.set(0, this.rotationView, 0);
        //      this.player.scale.set(this.scale, this.scale, this.scale);
        //      this.mixer = new THREE.AnimationMixer(fbx);
        //      // console.log(fbx);
        //
        //      const animationAction = this.mixer.clipAction(fbx.animations[0]);
        //      this.activeAction = animationAction;
        //      this.animationActions.push(animationAction);
        //      // this.setAction(animationAction);
        //
        //      // const action = this.mixer.clipAction(fbx.animations[0]);
        //      // action.play();
        //
        //      this.scene.add(this.player);
        //      // this.player.rotation.set(new THREE.Vector3(0, 0, Math.PI / 2));
        //      // console.log(this.player.rotation);
        //      this.loadAction("/character/mutant/Idle.fbx", "idle");
        //      this.loadAction("/character/mutant/Walking.fbx", "run");
        //      this.loadAction("/character/mutant/Jumping.fbx", "jump");
        //      this.loadAction("/character/mutant/Mutant Swiping.fbx", "attack");
        //    },
        //    undefined,
        //    (error) => {
        //      console.error(error);
        //    }
        //  );
        //
        //  // this.loader.load(
        //  //   "/mutant/Idle.fbx",
        //  //   (anim) => {
        //  //     console.log(anim);
        //  //     const animationAction = this.mixer.clipAction(anim.animations[0]);
        //  //     this.animationActions.push(animationAction);
        //  //     // animationsFolder.add(animations, "default");
        //
        //  //     // animationAction.play();
        //
        //  //     // this.setAction(animationAction);
        //
        //  //     // const action = this.mixer.clipAction(anim.animations[0]);
        //  //     // action.play();
        //  //     // animationsFolder.add(animations, "walking");
        //  //     // console.log(fbx);
        //  //     // this.zombieAnims["walkAnim"] = fbx.animations[0];
        //  //     // this.assets["walkAnim"] = fbx;
        //  //     // this.zombieAnims = {};
        //  //     // this.SetAnim("run", this.assets["walkAnim"]);
        //  //   },
        //  //   undefined,
        //  //   (error) => {
        //  //     console.error(error);
        //  //   }
        //  // );
        //
        //  // this.loader.load(
        //  //   "/mutant/Walking.fbx",
        //  //   (fbx) => {
        //  //     console.log(fbx);
        //  //     const animationAction = this.mixer.clipAction(fbx.animations[0]);
        //  //     this.animationActions.push(animationAction);
        //  //     // const action = this.mixer.clipAction(fbx.animations[0]);
        //  //     // action.play();
        //  //     // animationsFolder.add(animations, "walking");
        //  //     // console.log(fbx);
        //  //     // this.zombieAnims["walkAnim"] = fbx.animations[0];
        //  //     // this.assets["walkAnim"] = fbx;
        //  //     // this.zombieAnims = {};
        //  //     // this.SetAnim("run", this.assets["walkAnim"]);
        //  //   },
        //  //   undefined,
        //  //   (error) => {
        //  //     console.error(error);
        //  //   }
        //  // );
        //
        //  // this.SetAnim("idle", this.assets["idleAnim"]);
        //  // this.SetAnim("run", this.assets["runAnim"]);
        //  // this.SetAnim("attack", this.assets["attackAnim"]);
        //  // this.SetAnim("die", this.assets["dieAnim"]);
        //  setTimeout(() => {
        //    this.modelReady = true;
        //    console.log(this.animationActions);
        //    console.log("model ready");
        //  }, 500);
        //}

        showSelectMenu(visible = true) {
          document.querySelectorAll(".startGame").forEach((e) => {
            e.addEventListener("click", (e) => {
              //const Annuaire = new annuaire(e.target.id);
              //this.scale = Annuaire.scale;
              //this.yAtOrigin = Annuaire.yAtOrigin;
              //let path = Annuaire.path;
              //this.load(path);
              let modalBodyInput =
                exampleModal.querySelector(".modal-body input");
              console.log(modalBodyInput.value);
              this.loading = true;
              document.querySelector(".loadingScreen").style.visibility =
                "visible";
              document.getElementById("selectMenu").style.visibility = "hidden";
              this.socket.emit("joinParty", modalBodyInput.value);
              this.StartGame();
            });
          });
          this.addPartyList();
          //document
          //  .querySelector("#createParty")
          //  .addEventListener("click", (e) => this.createParty(e));

          //document.querySelector("#thanos").addEventListener("click", (e) => {
          //  //const Annuaire = new annuaire(e.target.id);
          //  //this.scale = Annuaire.scale;
          //  //this.yAtOrigin = Annuaire.yAtOrigin;
          //  //let path = Annuaire.path;
          //  //this.load(path);
          //  this.socket.emit("joinParty", e.target.id);
          //  document.getElementById("selectMenu").style.visibility = "hidden";
          //  this.StartGame();
          //});

          // img.forEach((e) => {
          //   e.addEventListener("click", (e) => this.load(e));
          // });

          document.getElementById("menu").style.visibility = "hidden";
          document.getElementById("selectMenu").style.visibility = "visible";
        }

        createParty() {}

        addPartyList() {
          let party = "";
          for (let i = 0; i < this.partyList.length; i++) {
            party =
              party +
              `<div party="${this.partyList[i]}" class="party">${this.partyList[i]}<button party="${this.partyList[i]}" class="startJoinGame">Join</button></div>`;
          }
          document.querySelector("#partyList").innerHTML = party;
          document.querySelectorAll(".startJoinGame").forEach((e) => {
            e.addEventListener("click", (e) => {
              let party = e.target.getAttribute("party");
              console.log(e.target);
              console.log(party);
              this.loading = true;
              document.querySelector(".loadingScreen").style.visibility =
                "visible";
              document.getElementById("selectMenu").style.visibility = "hidden";
              this.socket.emit("joinParty", party);
              this.StartGame();
            });
          });
        }

        ShowMenu(visible = true) {
          document.getElementById("menu").style.visibility = visible
            ? "visible"
            : "hidden";
        }

        //SetupTactileButton() {
        //  var container = document.createElement("div");
        //  container.style.position = "absolute";
        //  container.style.bottom = "0px";
        //  container.style.left = "0px";
        //  container.id = "tactile_container";
        //  var left = document.createElement("button");
        //  left.innerHTML = "Go Left";
        //  left.id = "left";
        //  var right = document.createElement("button");
        //  right.innerHTML = "Go Right";
        //  right.id = "right";
        //  document.body.appendChild(container);
        //  document.getElementById("tactile_container").appendChild(left);
        //  document.getElementById("tactile_container").appendChild(right);
        //  this.tactileControls();
        //}

        //tactileControls() {
        //  document.getElementById("left").addEventListener("click", () => {
        //    this._keys.moveLeft = 1;
        //  });
        //  document.getElementById("right").addEventListener("click", () => {
        //    console.log("right");
        //    this._keys.moveRight = 1;
        //  });
        //}

        showResources() {
          document.querySelector("#resources").style.visibility = "visible";
        }

        createRender() {
          this.collisionConfiguration =
            new Ammo.btDefaultCollisionConfiguration();
          this.dispatcher = new Ammo.btCollisionDispatcher(
            this.collisionConfiguration
          );
          this.overlappingPairCache = new Ammo.btDbvtBroadphase();
          this.solver = new Ammo.btSequentialImpulseConstraintSolver();

          this.dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(
            this.dispatcher,
            this.overlappingPairCache,
            this.solver,
            this.collisionConfiguration
          );
          this.dynamicsWorld.setGravity(new Ammo.btVector3(0, this.GRAVITY, 0));

          this.renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: false,
            powerPreference: "high-performance",
            //depthBuffer: false
          });
          //this.render.setPixelRatio(window.devicePixelRatio);
          this.renderer.setSize(window.innerWidth, window.innerHeight);
          document
            .querySelector("#three")
            .appendChild(this.renderer.domElement);
          //this.renderer.physicallyCorrectLights = true

          this.scene = new THREE.Scene();

          this.camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            1,
            1000
          );
          this.camera.position.set(0, 10, 50);
          this.camera.lookAt(0, -30, 0);

          // this.scene.background = new THREE.Color(0xffffff);

          this.loader = new THREE.TextureLoader();
          this.GLTFLoader = new GLTFLoader();
          this.FBXLoader = new FBXLoader();
        }

        eventResize() {
          window.addEventListener("resize", () => {
            this.renderer.setSize(window.innerWidth, window.innerHeight);
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
          });
        }

        createLight() {
          const ambiantLight = new THREE.AmbientLight(0xffffff, 1); // soft white light
          this.scene.add(ambiantLight);
          this.light = new THREE.DirectionalLight(0xffffff, 1);
          this.light.position.set(0, 0, 10);
          this.scene.add(this.light);
        }

        // SetAnim(name, clip) {
        //   const action = this.mixer.clipAction(clip);
        //   this.animations[name] = { clip, action };
        // }

        loadAction(path, name) {
          console.log(path);
          this.FBXLoader.load(
            path,
            (fbx) => {
              const animationAction = this.mixer.clipAction(fbx.animations[0]);
              this.animationActions[name] = animationAction;
            },
            undefined,
            (error) => {
              console.error(error);
            }
          );
        }

        setAction(toAction) {
          //console.log(toAction);
          // toAction.play();
          if (toAction != this.activeAction && toAction != undefined) {
            this.lastAction = this.activeAction;
            this.activeAction = toAction;
            //lastAction.stop()
            this.lastAction.fadeOut(0.5);
            toAction.reset();
            toAction.fadeIn(1);
            toAction.play();
            this.socket.emit("action", toAction._clip.name);
          }
        }

        //loadBackground() {
        //  const IMGloader = new THREE.TextureLoader();
        //  var texture = IMGloader.load("/background/teletebise.png");
        //  // console.log(window.innerWidth, window.innerHeight);
        //  var backgroundMesh = new THREE.Mesh(
        //    new THREE.PlaneGeometry(
        //      window.innerWidth / 8.28,
        //      window.innerHeight / 8.28,
        //      1
        //    ),
        //    new THREE.MeshBasicMaterial({
        //      map: texture,
        //    })
        //  );
        //  backgroundMesh.position.z = -10;
        //  this.scene.add(backgroundMesh);
        //  this.ShowMenu();
        //}

        keyboardControlsDown(e) {
          var key = e.keyCode;
          // console.log(key);

          switch (key) {
            case 90:
            case 38:
              this._keys.moveForward = 1;
              break;
            case 81:
            case 37:
              // console.log(this.scene.getObjectByName("player"));
              // this.scene.getObjectByName("player").position.y -= 0.9;
              this._keys.moveLeft = 1;
              this.seeAtRight = false;
              //this.setAction(this.animationActions["run"]);
              break;
            case 83:
            case 40:
              this._keys.moveBackward = 1;
              break;
            case 68:
            case 39:
              this._keys.moveRight = 1;
              this.seeAtRight = true;
              //this.setAction(this.animationActions["run"]);
              break;
            case 32:
              // if (this.canJump)
              this.jump = true;
              break;

            // case 13:
            //   console.log(this.player.userData.physicsBody);
            //   break;
          }
          //this.socket.emit("pos", this.player.position.toArray());
        }

        keyboardControlsUp(e) {
          switch (e.keyCode) {
            case 90:
            case 38:
              this._keys.moveForward = 0;
              break;
            case 81:
            case 37:
              this._keys.moveLeft = 0;
              if (this._keys.moveRight == 1) {
                this.seeAtLeft = false;
              }
              //this.setAction(this.animationActions["idle"]);
              break;
            case 83:
            case 40:
              this._keys.moveBackward = 0;
              break;
            case 68:
            case 39:
              this._keys.moveRight = 0;
              if (this._keys.moveLeft == 1) {
                this.seeAtRight = false;
              }
              //this.setAction(this.animationActions["idle"]);
              break;
            case 32:
              // if (this.canJump)
              this.jump = false;
              break;
          }
          //this.socket.emit("pos", this.player.position.toArray());
        }

        keyboardControls() {
          window.addEventListener(
            "keydown",
            (e) => this.keyboardControlsDown(e),
            false
          );
          window.addEventListener(
            "keyup",
            (e) => this.keyboardControlsUp(e),
            false
          );
          window.addEventListener("keydown", (e) => this.collect(e), false);
        }

        collect(e) {
          if (this.canCollect != true) return;
          if (e.keyCode != 69) return;
          let obj = this.scene.getObjectByName("click");
          if (!obj || obj.collectable == false) return;

          if (
            Math.round(
              this.player.position.clone().distanceTo(obj.position.clone()) * 10
            ) /
              10 <
            30
          ) {
            new TimerResource(obj, this.scene);
            this.addResources(obj.prop, 5);
          } else {
            document.querySelector("#error").innerHTML = "<p>Too far</p>";
          }
        }

        addResources(value, nbr) {
          document.querySelector(`#${value}Count`).textContent =
            Number(document.querySelector(`#${value}Count`).textContent) + nbr;
        }

        mouseDownCanvas(e) {
          e.preventDefault();
          this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
          this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

          this.raycaster.setFromCamera(this.mouse, this.camera);
          let intersects = this.raycaster.intersectObjects(this.clickableObjs);

          if (intersects.length > 0) {
            //console.log(intersects[0].object);
            if (intersects[0].object.name == "click") {
              intersects[0].object.name = "";
              this.cursor_cube.children.forEach(
                (e) => (e.material.opacity = 0)
              );
              this.cubePropertiesHidden();
              this.gridSelectorHidden();
              return;
            }
            if (this.scene.getObjectByName("click") != undefined)
              this.scene.getObjectByName("click").name = "";

            // If there is a match mouse/block (if the array is not empty)
            var SelectedBloc = intersects[0].object; // we choose the first targetable element
            intersects[0].object.name = "click";
            //SelectedBloc.material.color.set( 0xff0000 );
            this.cursor_cube.position.set(
              SelectedBloc.position.x,
              SelectedBloc.position.y,
              SelectedBloc.position.z
            );
            this.cursor_cube.children.forEach(
              (e) => (e.material.opacity = 0.5)
            );
            this.cursor_cube.children.forEach(
              (e) => (e.material.emissive.g = 0.5)
            );
            //this.cursor_cube.material.opacity = 0.5;
            //this.cursor_cube.material.emissive.g = 0.5;
            this.cubeProperties(
              SelectedBloc.position.x,
              SelectedBloc.position.z,
              intersects[0].object.prop,
              intersects[0].object.name,
              intersects[0].object
            );
          }
        }

        mouseUp() {
          this.cursor_cube.children.forEach((e) => (e.material.emissive.g = 0));
        }

        mouseControls() {
          const cursor_material = new THREE.MeshPhongMaterial({
            transparent: true,
            opacity: 0,
            color: 0xc0392b,
          });
          //const bMat = new THREE.MeshStandardMaterial({ color: 0x0392b });

          const cursor_geometry = [];
          for (let i = 0; i < 12; i++) {
            cursor_geometry.push(
              new THREE.Mesh(
                new THREE.BoxGeometry(2.5, 4, 2.5),
                cursor_material
              )
            );
          }
          cursor_geometry[0].position.set(-8.75, 0, -8.75);
          cursor_geometry[1].position.set(-6.24, 0, -8.75);
          cursor_geometry[2].position.set(-8.75, 0, -6.24);
          cursor_geometry[3].position.set(8.75, 0, -8.75);
          cursor_geometry[4].position.set(6.24, 0, -8.75);
          cursor_geometry[5].position.set(8.75, 0, -6.24);
          cursor_geometry[6].position.set(8.75, 0, 8.75);
          cursor_geometry[7].position.set(6.24, 0, 8.75);
          cursor_geometry[8].position.set(8.75, 0, 6.24);
          cursor_geometry[9].position.set(-8.75, 0, 8.75);
          cursor_geometry[10].position.set(-6.24, 0, 8.75);
          cursor_geometry[11].position.set(-8.75, 0, 6.24);

          this.cursor_cube = new THREE.Group();
          for (const e of cursor_geometry) {
            this.cursor_cube.add(e);
          }
          //this.cursor_cube.children.forEach((e) => (e.material.opacity = 0));
          this.scene.add(this.cursor_cube);
          document
            .querySelector("#three > canvas")
            .addEventListener(
              "pointerdown",
              (e) => this.mouseDownCanvas(e),
              false
            );
          document.addEventListener("pointerup", (e) => this.mouseUp(e), false);
        }

        //buildHouse(e) {
        //  e.stopPropagation();
        //  e.preventDefault();
        //  if (document.querySelector("#woodCount").textContent >= 50) {
        //    document.querySelector("#woodCount").textContent =
        //      Number(document.querySelector("#woodCount").textContent) - 50;
        //    let x = Number(document.querySelector("#x").innerHTML);
        //    let z = Number(document.querySelector("#z").innerHTML);
        //    this.loadStructure(
        //      "house/01_medieval_house_low_poly.glb",
        //      x,
        //      -23,
        //      z,
        //      2,
        //      true,
        //      Math.PI / 2
        //    );
        //    this.Villagers.createVillager(
        //      [x * 20, -25, z * 20 - 5],
        //      this.houseN
        //    );
        //
        //    this.houseN = this.houseN + 1;
        //    this.Villagers.houseN = this.houseN;
        //  } else {
        //    document.querySelector("#error").innerHTML =
        //      "<p>No enought Wood</p>";
        //  }
        //}
        //
        //buildMine(e) {
        //  e.stopPropagation();
        //  e.preventDefault();
        //  if (document.querySelector("#stoneCount").textContent >= 50) {
        //    document.querySelector("#stoneCount").textContent =
        //      Number(document.querySelector("#stoneCount").textContent) - 50;
        //    let x = Number(document.querySelector("#x").innerHTML);
        //    let z = Number(document.querySelector("#z").innerHTML);
        //    this.loadStructure(
        //      "low-poly_mine/scene.gltf",
        //      x + 0.5,
        //      -28,
        //      z + 0.5,
        //      1,
        //      false,
        //      -Math.PI / 2
        //    );
        //    //this.Villagers.createVillager([x * 20, -25, z * 20], this.houseN);
        //
        //    //this.houseN = this.houseN + 1;
        //    //this.Villagers.houseN = this.houseN;
        //  } else {
        //    document.querySelector("#error").innerHTML =
        //      "<p>No enought Stone</p>";
        //  }
        //}
        //buildBlacksmithHouse(e) {
        //  e.stopPropagation();
        //  e.preventDefault();
        //  if (document.querySelector("#stoneCount").textContent >= 50) {
        //    document.querySelector("#stoneCount").textContent =
        //      Number(document.querySelector("#stoneCount").textContent) - 50;
        //    let x = Number(document.querySelector("#x").innerHTML);
        //    let z = Number(document.querySelector("#z").innerHTML);
        //    this.loadStructure(
        //      "blacksmiths_house/scene.gltf",
        //      x + 2,
        //      -28,
        //      z,
        //      0.1,
        //      false,
        //      Math.PI / 2
        //    );
        //    //this.Villagers.createVillager([x * 20, -25, z * 20], this.houseN);
        //
        //    //this.houseN = this.houseN + 1;
        //    //this.Villagers.houseN = this.houseN;
        //  } else {
        //    document.querySelector("#error").innerHTML =
        //      "<p>No enought Stone</p>";
        //  }
        //}
        //buildShop(e) {
        //  e.stopPropagation();
        //  e.preventDefault();
        //  if (document.querySelector("#stoneCount").textContent >= 50) {
        //    document.querySelector("#stoneCount").textContent =
        //      Number(document.querySelector("#stoneCount").textContent) - 50;
        //    let x = Number(document.querySelector("#x").innerHTML);
        //    let z = Number(document.querySelector("#z").innerHTML);
        //    let y = -28;
        //    this.socket.emit("structure", {
        //      path: "small_store/scene.gltf",
        //      x: x,
        //      y: y,
        //      z: z,
        //      scale: 0.23,
        //      house: false,
        //      rotation: 0,
        //    });
        //    let emit = {
        //      path: "small_store/scene.gltf",
        //      x: x,
        //      y: y,
        //      z: z,
        //      scale: 0.23,
        //      house: false,
        //      rotation: 0,
        //    };
        //    console.log(Object.keys(emit).map((_) => emit[_]));
        //
        //    this.loadStructure("small_store/scene.gltf", x, y, z, 0.23, false);
        //    //this.Villagers.createVillager([x * 20, -25, z * 20], this.houseN);
        //
        //    //this.houseN = this.houseN + 1;
        //    //this.Villagers.houseN = this.houseN;
        //  } else {
        //    document.querySelector("#error").innerHTML =
        //      "<p>No enought Stone</p>";
        //  }
        //}
        buildStructure(
          e,
          unit,
          unitN,
          path,
          x,
          y,
          z,
          scale,
          house,
          rotation,
          prop
        ) {
          e.stopPropagation();
          e.preventDefault();
          console.log(`#${unit}Count`);
          if (this.scene.getObjectByName("click").prop != "plain")
            return (document.querySelector("#error").innerHTML =
              "<p>No Good Place</p>");
          if (document.querySelector(`#${unit}Count`).textContent >= unitN) {
            document.querySelector(`#${unit}Count`).textContent =
              Number(document.querySelector(`#${unit}Count`).textContent) -
              unitN;
            let x_ = Number(document.querySelector("#x").innerHTML);
            let z_ = Number(document.querySelector("#z").innerHTML);
            this.socket.emit("structure", {
              path: path,
              x: x_ + x,
              y: y,
              z: z_ + z,
              scale: scale,
              house: house,
              rotation: rotation,
              prop: prop,
              block: this.scene.getObjectByName("click").id,
            });
          } else {
            document.querySelector("#error").innerHTML =
              "<p>No enought Stone</p>";
          }
        }

        showGridSelector() {
          document.querySelector("#gridSelector").style.visibility = "visible";
        }

        gridSelectorHidden() {
          document.querySelector("#gridSelector").style.visibility = "hidden";
        }

        cubeProperties(x, z, prop, name, obj) {
          //const fragment = document.createDocumentFragment();

          const li = document.querySelector("#info");
          li.style.visibility = "visible";
          //li = document.body.appendChild(document.createElement("div"));
          li.innerHTML = `cube :<br>x:<div id="x">${
            x / 20
          }</div>,z:<div id="z">${z / 20}</div>`;
          this.showGridSelector();
          this.Villagers.addVillagerMenu(x, z);
          console.log(prop);
          if (prop == "plain") {
            this.canCollect = false;
            //li.innerHTML =
            //  li.innerHTML + `<button id="buildHouse">Build house</button>`;
            //document
            //  .querySelector("#buildHouse")
            //  .addEventListener("click", (e) => this.buildHouse(e), false);
          } else if (prop == "stone") {
            this.canCollect = true;
            li.innerHTML = li.innerHTML + `<p>Press E to collect</p>`;
          } else if (prop == "wood") {
            this.canCollect = true;
            li.innerHTML = li.innerHTML + `<p>Press E to collect</p>`;
          }
          //if (color.g != 1) {
          //  li.innerHTML = li.innerHTML + `<br><button>Harvest</button>`
          //}
          //document.body.appendChild(fragment);
        }

        addVillagerMenu() {
          if (this.houseN == 1) return;
          if (document.querySelector("#noVillagerText")?.style) {
            document.querySelector("#noVillagerText").style.visibility =
              "hidden";
          }
          let workerList = "";
          for (let i = 1; i < this.houseN; i++) {
            console.log(i);
            workerList =
              workerList +
              `<dl class="villagerList"><dt class="houseNumber">House n°${i}</dt><dd class="villagerName"><button villagerid="${
                i + ".1"
              }" class="jobButton">Villageois ${i}.1<br/><div villagerid="${
                i + ".1"
              }" class="job">${
                this.villagers[i + ".1"].job
              }</div></button></dd><dd class="villagerName"><button villagerid="${
                i + ".2"
              }" class="jobButton">Villageois ${i}.2<br/><div villagerid="${
                i + ".2"
              }" class="job">${
                this.villagers[i + ".2"].job
              }</div></button></dd><dd class="villagerName"><button villagerid="${
                i + ".3"
              }" class="jobButton">Villageois ${i}.3<br/><div villagerid="${
                i + ".3"
              }" class="job">${this.villagers[i + ".3"].job}
              </div></button></dd></dl>`;
          }
          document.querySelector("#collectMenu").innerHTML = workerList;
          document.querySelectorAll(".jobButton").forEach((e) => {
            e.removeEventListener("click", (e) => this.doJob(e), false);
          });
          document.querySelectorAll(".jobButton").forEach((e) => {
            e.addEventListener("click", (e) => this.doJob(e), false);
          });
        }

        doJob(e) {
          this.villagers[e.target.getAttribute("villagerid")].job = `from ${
            this.scene.getObjectByName("click").prop
          } at ${this.scene.getObjectByName("click").position.x / 20}, ${
            this.scene.getObjectByName("click").position.z / 20
          } to House  n°${e.target.getAttribute("villagerid").split(".")[0]}`;
          this.villagers[e.target.getAttribute("villagerid")].collectTarget = [
            this.scene.getObjectByName("click").position.x,
            -28,
            this.scene.getObjectByName("click").position.z,
          ];
          this.villagers[e.target.getAttribute("villagerid")].jobType =
            this.scene.getObjectByName("click").prop;

          this.addVillagerMenu();
        }

        cubePropertiesHidden() {
          document.querySelector("#info").style.visibility = "hidden";
        }

        //attack() {
        //  this.setAction(this.animationActions["attack"]);
        //}

        //updateMovement() {
        //  // const player = this.scene.getObjectByName("player");
        //  // this.player.position.y = this.player.position.y + 0.2;
        //  // console.log(this.moveLeft);
        //  if (this._keys.moveLeft == 1) {
        //    // console.log("left");
        //    this.rotationView = 1;
        //    this.setAction(this.animationActions["run"]);
        //    // this.player.position.x -= this.speed;
        //  }
        //  if (this._keys.moveRight == 1) {
        //    // console.log("right");
        //    this.rotationView = -1;
        //    this.setAction(this.animationActions["run"]);
        //    // this.player.position.x += this.speed;
        //  }
        //}

        updateJump() {
          if (this.jump) {
            // console.log("jump");
            this.player.position.y = this.player.position.y + 5;
            // canJump = false;
            this.jump = false;
          }
        }

        //startAmmo() {
        //  Ammo().then((Ammo) => {
        //    Ammo = Ammo;
        //    this.AmmoClone = Ammo;
        //    this.createAmmo(Ammo);
        //  });
        //}

        createAmmo() {
          this.TempTransform = new Ammo.btTransform();
          this.tempVecJump = new Ammo.btVector3();

          //this.setupGraphicsWolrd(Ammo);
          this.createMap();
          this.CreatePlayer();
          //this.CreatePlayerLoad();
          //this.loadStructure();
        }

        loadStructure(structure, x, y, z, scale, house, rotation, prop, block) {
          this.GLTFLoader.load(
            "structure/" + structure,
            (gltf) => {
              let structure = gltf.scene;
              structure.position.set(x * 20, y, z * 20);
              structure.scale.set(scale, scale, scale);
              if (rotation) structure.rotation.y = rotation;
              if (house) structure.name = `house${this.houseN}`;
              if (prop) this.scene.getObjectById(block).prop = prop;
              structure.matrixAutoUpdate = false;
              structure.updateMatrix();
              this.scene.add(structure);
            },
            undefined,
            (error) => {
              console.error(error);
            }
          );
          if (house) {
            this.Villagers.createVillager(
              [x * 20, -25, z * 20 - 5],
              this.houseN
            );

            this.houseN = this.houseN + 1;
            this.Villagers.houseN = this.houseN;
          }
        }

        setupGraphicsWolrd() {
          let collisionConfiguration =
            new Ammo.btDefaultCollisionConfiguration();
          let dispatcher = new Ammo.btCollisionDispatcher(
            collisionConfiguration
          );
          let overlappingPairCache = new Ammo.btDbvtBroadphase();
          let solver = new Ammo.btSequentialImpulseConstraintSolver();

          this.dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(
            dispatcher,
            overlappingPairCache,
            solver,
            collisionConfiguration
          );
          this.dynamicsWorld.setGravity(new Ammo.btVector3(0, this.GRAVITY, 0));
        }

        //randomSeed(e) {
        //  let x = Math.sin(e++) * 10000;
        //  return Math.floor((x - Math.floor(x)) * 1000000000);
        //}

        //randomNumber(e) {
        //  e++;
        //  let x = Math.sin(e++) * 10000;
        //  return Math.floor((x - Math.floor(x)) * 100);
        //}
        //

        average(e) {
          this.total = this.total + 1;
          this.totalAdd = this.totalAdd + e;
        }

        moreRandomNumber(e) {
          let randomNumber = new Math.seedrandom(e)();
          return Math.round(randomNumber * 10000) / 100;
        }

        fullSeed() {
          let worldInGen = this.generatingSeed();
          return worldInGen * 10 ** (worldInGen.toString().length - 2);
        }

        addSeedRandom() {
          let sSeed = this.fullSeed().toString();
          for (let i = 0; i < sSeed.length; i = i + 2) {
            this.seedRandom.push(
              this.moreRandomNumber(
                Number(sSeed.charAt(i) + sSeed.charAt(i + 1))
              )
            );
          }
        }

        createMap() {
          this.CreateSolidFloor(20, 20);

          this.total = 0;
          this.totalAdd = 0;

          this.generatingSeed = new Math.seedrandom(this.seed);
          this.seedRandom = [];
          //this.sSeed = this.generatingSeed.toString();
          this.structureSeed = 1;
          this.addSeedRandom();
          //for (let i = 0; i < this.sSeed.length; i++) {
          //  this.seedRandom.push(+this.sSeed.charAt(i));
          //}

          this.textureCubeGrass = this.loader.load("img/Cartoon_green.jpg");
          this.textureCubeRock = this.loader.load("img/andesite.png");
          this.textureCubeFarm = this.loader.load(
            "https://static.wikia.nocookie.net/minecraft_gamepedia/images/3/37/Dirt_Path_%28top_texture%29_JE2_BE2.png"
          );
          for (let x = this.mapSize.x * -0.5; x < this.mapSize.x * 0.5; x++) {
            for (let z = this.mapSize.z * -0.5; z < this.mapSize.z * 0.5; z++) {
              //let random = Math.floor(Math.random() * 100);
              if (
                !this.seedRandom[this.structureSeed] ||
                this.seedRandom[this.structureSeed] == NaN
              ) {
                this.addSeedRandom();
              }
              let random = this.seedRandom[this.structureSeed];
              //console.log(random);
              this.average(random);

              if (random < this.randomP.houseVillager) {
                this.createFloor(x, z, this.textureCubeGrass, "houseVillager");

                this.loadStructure("house_minecraft/scene.gltf", x, -28, z, 20);
                //this.createVillager(Ammo = AmmoClone, x,z)
              } else if (random < this.randomP.stone) {
                console.log("stone");
                this.createFloor(x, z, this.textureCubeRock, "stone");
                this.loadStructure(
                  "rock_and_plants/scene.gltf",
                  x + 0.1,
                  -30,
                  z - 0.1,
                  1.75
                );
              } else if (random < this.randomP.wood) {
                this.createFloor(x, z, this.textureCubeGrass, "wood");
                this.loadStructure(
                  "tree_low-poly_3d_model/scene.gltf",
                  x,
                  -28,
                  z,
                  0.035
                );
              } else if (random < this.randomP.farmWithWheat) {
                this.createFloor(x, z, this.textureCubeFarm, "wheat");
                //this.loadStructure("source/Field of wheat--eWhaaKNh755/FieldOfWheat(1).gltf", x, z, 1.2);
              } else if (random < this.randomP.farmWithoutWheat) {
                this.createFloor(x, z, this.textureCubeFarm);
              } else {
                this.createFloor(x, z, this.textureCubeGrass, "plain");
              }
              this.structureSeed++;
            }
          }
          console.log("true average = ", this.totalAdd / this.total);
        }

        //createVillager(position, house) {
        //  for (let i = 1; i < 4; i++) {
        //    this.FBXLoader.load(
        //      "/character/stickman/source/Simple_Character.fbx",
        //      (fbx) => {
        //        this.villagers[house + "." + i] = fbx;
        //        console.log(position);
        //        this.villagers[house + "." + i].position.set(...position);
        //        this.villagers[house + "." + i].scale.set(0.03, 0.03, 0.03);
        //        this.villagers[house + "." + i].house = house;
        //        this.villagers[house + "." + i].job = "Is not working";
        //        this.villagers[house + "." + i].housePos = position;
        //        this.villagers[house + "." + i].stay = false;
        //        this.villagers[house + "." + i].returnHouse = false;
        //
        //        this.mixer[house + "." + i] = new THREE.AnimationMixer(fbx);
        //
        //        if (fbx.animations[0]) {
        //          const animationAction = this.mixer[
        //            house + "." + i
        //          ].clipAction(fbx.animations[1]);
        //          animationAction.play();
        //          this.activeAction = animationAction;
        //          this.villagerActions.push(animationAction);
        //        }
        //        this.scene.add(this.villagers[house + "." + i]);
        //      },
        //      undefined,
        //      (error) => {
        //        console.error(error);
        //      }
        //    );
        //    setTimeout(() => {
        //      this.modelReady = true;
        //      console.log(this.villagerActions);
        //      console.log("model ready");
        //    }, 500);
        //  }
        //  this.addVillagerMenu();
        //}

        createFloor(x, z, texture, property) {
          let position = { x: 20.001 * x, y: -30, z: 20.001 * z },
            scale = { x: 20, y: 3, z: 20 },
            quat = { x: 0, y: 0, z: 0, w: 1 },
            mass = 0;

          //const textureCube = this.loader.load(texture);
          //var materials = [
          //new THREE.MeshLambertMaterial({
          //    map: this.loader.load(texture)
          // })
          // ];

          const geometry = new THREE.BoxGeometry(scale.x, scale.y, scale.z);
          const material = new THREE.MeshBasicMaterial({
            map: texture,
          });

          let blockPlane = new THREE.Mesh(geometry, material);
          blockPlane.position.set(position.x, position.y, position.z);
          if (property) blockPlane.prop = property;
          blockPlane.collectable = true;
          this.scene.add(blockPlane);

          this.clickableObjs.push(blockPlane);
          blockPlane.matrixAutoUpdate = false;
          blockPlane.updateMatrix();
        }

        CreateSolidFloor(x, z) {
          let quat = { x: 0, y: 0, z: 0, w: 1 },
            mass = 0;

          const geometry = new THREE.BoxGeometry(x * 0, 3, z * 0);
          const material = new THREE.MeshBasicMaterial({
            //transparent: true,
            opacity: 0,
            color: 0x000000,
          });

          let blockPlane = new THREE.Mesh(geometry, material);
          blockPlane.position.set(0, -33, 0);
          this.scene.add(blockPlane);

          let transform = new Ammo.btTransform();
          transform.setIdentity();
          transform.setOrigin(new Ammo.btVector3(0, -33, 0));
          transform.setRotation(
            new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w)
          );

          let motionState = new Ammo.btDefaultMotionState(transform);
          let localInertia = new Ammo.btVector3(0, 0, 0);
          let shape = new Ammo.btBoxShape(
            new Ammo.btVector3(x * 20 * 0.5, 3 * 0.5, z * 20 * 0.5)
          );
          shape.setMargin(0.05);
          shape.calculateLocalInertia(mass, localInertia);

          let rigidBodyInfo = new Ammo.btRigidBodyConstructionInfo(
            mass,
            motionState,
            shape,
            localInertia
          );

          let rigidBody = new Ammo.btRigidBody(rigidBodyInfo);

          // rigidBody.setFriction(4);
          // rigidBody.setRollingFriction(10);

          this.dynamicsWorld.addRigidBody(rigidBody);
          blockPlane.matrixAutoUpdate = false;
          blockPlane.updateMatrix();
        }

        CreatePlayer() {
          this.socket.emit("newPlayer");
          //this.socket.on("test", (e) => {
          //  console.log(e);
          //});
          this.socket.on("pos", (d) => {
            const [id, anim, pos] = d;
            if (!(id in this.players)) {
              console.log("new chalenger");
              console.log(id);
              let scale = { x: 10, y: 10, z: 10 },
                quat = { x: 0, y: 0, z: 0, w: 1 },
                mass = 5,
                position = { x: 0, y: 10, z: 0 },
                height = 50,
                radius = 0.3;

              // const height = 1.3,
              //  radius = 0.3,
              //  mass = 5,
              //  position = { x: 30, y: 10, z: 0 },
              //  scale = { x: 10, y: 50, z: 10 },
              //  quat = { x: 0, y: this.rotationView, z: 0, w: 1 };

              //const geometry = new THREE.BoxGeometry(scale.x, scale.y, scale.z);
              //const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
              //const cube = (this.player = new THREE.Mesh(geometry, material));
              //cube.position.set(...d);
              //
              //cube.name = "player";
              ////this.player = cube;
              //this.scene.add(cube);

              if (!this.playerIsLoading) {
                this.playerIsLoading = true;
                this.CreatePlayerLoad(pos, id);
                console.log("main palyer");
              } else {
                console.log("other");
                this.GLTFLoader.load(
                  "/character/gentle_stickman/scene.gltf",
                  (fbx) => {
                    console.log(fbx);
                    this.players[id] = fbx.scene;
                    this.players[id].position.set(...pos);
                    this.players[id].scale.set(7, 7, 7);

                    this.scene.add(this.players[id]);
                    this.playersAnim.CreatePlayerAnimation(
                      fbx.animations,
                      this.players[id]
                    );
                  },false,
                  (error) => {
                    console.error(error);
                  }
                );
                //const geometry = new THREE.BoxGeometry(
                //  scale.x,
                //  scale.y,
                //  scale.z
                //);
                //const material = new THREE.MeshBasicMaterial({
                //  color: 0xffffff,
                //});
                //const cube = new THREE.Mesh(geometry, material);
                //cube.position.set(...d);
                //
                //cube.name = "player";
                ////this.player = cube;
                //this.scene.add(cube);
                //console.log(id);
                //this.players[id] = cube;
              }
            }
            //if (this.player == this.players[id])
            if (this.players[id]?.position && this.players[id] != this.player){

              this.players[id].position.set(...pos);
            this.playersAnim.setAction(anim, this.players[id].id);
            }
          });
          this.socket.on("deletePlayer", (id) => {
            console.log(id);
            console.log(this.players[id]);
            this.playersAnim.deletePlayer();
            this.scene.remove(this.players[id]);
          });
        }

        rigidBody(object, quat, scale, pos, mass) {
          let transform = new Ammo.btTransform();
          transform.setIdentity();
          transform.setOrigin(new Ammo.btVector3(pos));
          transform.setRotation(
            new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w)
          );

          let motionState = new Ammo.btDefaultMotionState(transform);
          let localInertia = new Ammo.btVector3(0, 0, 0);
          //todo peut etre changer 0,5
          let shape = new Ammo.btBoxShape(
            new Ammo.btVector3(scale.x, scale.y, scale.z)
          );

          //let shape = new Ammo.btCapsuleShape(radius, height);
          // shape.setMargin(0.05);
          // shape.calculateLocalInertia(mass, localInertia);

          let rigidBodyInfo = new Ammo.btRigidBodyConstructionInfo(
            mass,
            motionState,
            shape,
            localInertia
          );

          let rigidBody = new Ammo.btRigidBody(rigidBodyInfo);

          rigidBody.setFriction(0);

          rigidBody.setActivationState(this.STATE.DISABLE_DEACTIVATION);

          this.dynamicsWorld.addRigidBody(rigidBody);
          object.userData.physicsBody = rigidBody;
          this.rigidBodies.push(object);
        }

        CreatePlayerLoad(pos, id, mainPlayer) {
          //let position = { x: 0, y: 10, z: 0 },
          //  scale = { x: 10, y: 10, z: 10 },
          //  quat = { x: 0, y: 0, z: 0, w: 1 },
          //  mass = 5,
          //  height = 50,
          //  radius = 0.3;
          //
          const height = 10,
            radius = 10,
            mass = 5,
            scale = { x: 10, y: 3, z: 10 },
            quat = { x: 0, y: 0, z: 0, w: 1 };
          //
          ////const geometry = new THREE.BoxGeometry(scale.x, scale.y, scale.z);
          ////const material = new THREE.MeshBasicMaterial({ color: 0xffffff });
          ////const cube = (this.player = new THREE.Mesh(geometry, material));
          ////cube.position.set(position.x, position.y, position.z);
          //
          ////cube.name = "player";
          ////this.player = cube;
          ////this.scene.add(this.player);
          //
          //this.FBXLoader.load("/character (1).gltf", (object) => {
          //  this.player = this.player = object;
          //  // object.set(position.x, position.y, position.z);
          //  // object.set(scale.x, scale.y, scale.z);
          //  // object.set(quat.x, quat.y, quat.z, quat.w);
          //  this.player.name = "player";
          //  // setTimeout(() => {
          //  //   console.log("1");
          //  //   this.scene.add(object);
          //  // }, 500);
          //});
          //
          //this.GLTFloader.onLoadComplete = function () {
          //  console.log("2");
          //  this.scene.add(this.player);
          //};
          //
          //let transform = new Ammo.btTransform();
          //transform.setIdentity();
          //transform.setOrigin(
          //  new Ammo.btVector3(position.x, position.y, position.z)
          //);
          //transform.setRotation(
          //  new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w)
          //);
          //
          //let motionState = new Ammo.btDefaultMotionState(transform);
          //let localInertia = new Ammo.btVector3(0, 0, 0);
          ////todo peut etre changer 0,5
          //let shape = new Ammo.btBoxShape(
          //  new Ammo.btVector3(scale.x, scale.y, scale.z)
          //);
          //
          ////let shape = new Ammo.btCapsuleShape(radius, height);
          //// shape.setMargin(0.05);
          //// shape.calculateLocalInertia(mass, localInertia);
          //
          //let rigidBodyInfo = new Ammo.btRigidBodyConstructionInfo(
          //  mass,
          //  motionState,
          //  shape,
          //  localInertia
          //);
          //
          //let rigidBody = new Ammo.btRigidBody(rigidBodyInfo);
          //
          //rigidBody.setFriction(0);
          //
          //rigidBody.setActivationState(this.STATE.DISABLE_DEACTIVATION);
          //
          //this.dynamicsWorld.addRigidBody(rigidBody);
          //this.player.userData.physicsBody = rigidBody;
          //this.rigidBodies.push(this.player);

          this.GLTFLoader.load(
            "/character/gentle_stickman/scene.gltf",
            (fbx) => {
              console.log(fbx);
              this.player = fbx.scene;
              this.player.name = "player";
              //this.player.rotation.set(0, this.rotationView, 0);
              this.player.position.set(...pos);
              this.player.scale.set(7, 7, 7);

              //this.player = cube;
              //this.scene.add(cube);
              //this.player = cube;
              this.players[id] = fbx.scene;
              this.mixer = new THREE.AnimationMixer(this.players[id]);
              // console.log(fbx);

              if (fbx.animations[0]) {
                const animationAction = this.mixer.clipAction(
                  fbx.animations[0]
                );
                animationAction.play();
                this.activeAction = animationAction;
                this.animationActions["idle"] = this.mixer.clipAction(
                  fbx.animations[0]
                );
                this.animationActions["run"] = this.mixer.clipAction(
                  fbx.animations[1]
                );
              }

              // this.setAction(animationAction);

              // const action = this.mixer.clipAction(fbx.animations[0]);
              // action.play();

              this.scene.add(fbx.scene);

              let transform = new Ammo.btTransform();
              transform.setIdentity();
              transform.setOrigin(new Ammo.btVector3(...pos));
              transform.setRotation(
                new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w)
              );

              let motionState = new Ammo.btDefaultMotionState(transform);
              let localInertia = new Ammo.btVector3(0, 0, 0);
              //todo peut etre changer 0,5
              let shape = new Ammo.btBoxShape(
                new Ammo.btVector3(scale.x, scale.y, scale.z)
              );

              //let shape = new Ammo.btCapsuleShape(radius, height);
              // shape.setMargin(0.05);
              // shape.calculateLocalInertia(mass, localInertia);

              let rigidBodyInfo = new Ammo.btRigidBodyConstructionInfo(
                mass,
                motionState,
                shape,
                localInertia
              );

              let rigidBody = new Ammo.btRigidBody(rigidBodyInfo);

              rigidBody.setFriction(0);

              rigidBody.setActivationState(this.STATE.DISABLE_DEACTIVATION);

              this.dynamicsWorld.addRigidBody(rigidBody);
              this.player.userData.physicsBody = rigidBody;
              this.rigidBodies.push(this.player);
              //this.playerBB = new THREE.Box3(
              //  new THREE.Vector3(),
              //  new THREE.Vector3()
              //).setFromObject(this.player);

              // this.player.rotation.set(new THREE.Vector3(0, 0, Math.PI / 2));
              // console.log(this.player.rotation);

              //this.loadAction("/character/mutant/Idle.fbx", "idle");
              //this.loadAction("/character/mutant/Walking.fbx", "run");
              //this.loadAction("/character/mutant/Jumping.fbx", "jump");
              //this.loadAction("/character/mutant/Mutant Swiping.fbx", "attack");
            },
            (e) => {
              console.log(e);
              console.log(e.loaded / e.total);
              if (e.loaded / e.total == 1) {
                setTimeout(() => {
                  this.modelReady = true;
                }, 2000);
              }
            },
            (error) => {
              console.error(error);
            }
          );

          // this.loader.load(
          //   "/mutant/Idle.fbx",
          //   (anim) => {
          //     console.log(anim);
          //     const animationAction = this.mixer.clipAction(anim.animations[0]);
          //     this.animationActions.push(animationAction);
          //     // animationsFolder.add(animations, "default");

          //     // animationAction.play();

          //     // this.setAction(animationAction);

          //     // const action = this.mixer.clipAction(anim.animations[0]);
          //     // action.play();
          //     // animationsFolder.add(animations, "walking");
          //     // console.log(fbx);
          //     // this.zombieAnims["walkAnim"] = fbx.animations[0];
          //     // this.assets["walkAnim"] = fbx;
          //     // this.zombieAnims = {};
          //     // this.SetAnim("run", this.assets["walkAnim"]);
          //   },
          //   undefined,
          //   (error) => {
          //     console.error(error);
          //   }
          // );

          // this.loader.load(
          //   "/mutant/Walking.fbx",
          //   (fbx) => {
          //     console.log(fbx);
          //     const animationAction = this.mixer.clipAction(fbx.animations[0]);
          //     this.animationActions.push(animationAction);
          //     // const action = this.mixer.clipAction(fbx.animations[0]);
          //     // action.play();
          //     // animationsFolder.add(animations, "walking");
          //     // console.log(fbx);
          //     // this.zombieAnims["walkAnim"] = fbx.animations[0];
          //     // this.assets["walkAnim"] = fbx;
          //     // this.zombieAnims = {};
          //     // this.SetAnim("run", this.assets["walkAnim"]);
          //   },
          //   undefined,
          //   (error) => {
          //     console.error(error);
          //   }
          // );

          // this.SetAnim("idle", this.assets["idleAnim"]);
          // this.SetAnim("run", this.assets["runAnim"]);
          // this.SetAnim("attack", this.assets["attackAnim"]);
          // this.SetAnim("die", this.assets["dieAnim"]);
          //setTimeout(() => {
          //  this.modelReady = true;
          //  console.log(this.animationActions);
          //  console.log("model ready");
          //}, 5000);
        }

        // QueryJump() {
        //   const dispatcher = this.dynamicsWorld.getDispatcher();
        //   const numManifolds = dispatcher.getNumManifolds();

        //   for (let i = 0; i < numManifolds; i++) {
        //     const contactManifold = dispatcher.getManifoldByIndexInternal(i);
        //     // console.log(contactManifold);
        //     const rb0 = Ammo.castObject(
        //       contactManifold.getBody0(),
        //       Ammo.btRigidBody
        //     );
        //     const rb1 = Ammo.castObject(
        //       contactManifold.getBody1(),
        //       Ammo.btRigidBody
        //     );

        //     // console.log(this.player.userData.physicsBody);
        //     // console.log(rb0);
        //     // console.log(rb1);

        //     if (
        //       rb0 != this.player.userData.physicsBody &&
        //       rb1 != this.player.userData.physicsBody
        //     ) {
        //       continue;
        //     }

        //     console.log("test");

        //     const numContacts = contactManifold.getNumContacts();
        //     // console.log(numContacts);

        //     for (let j = 0; j < numContacts; j++) {
        //       const contactPoint = contactManifold.getContactPoint(j);
        //       // console.log(contactPoint);

        //       const normal = contactPoint.get_m_normalWorldOnB();
        //       this.tempVecJump.setValue(normal.x(), normal.y(), normal.z());
        //       // console.log(this.tempVecJump);

        //       if (rb1 == this.player.userData.physicsBody) {
        //         this.tempVecJump.setValue(
        //           -this.tempVecJump.x(),
        //           -this.tempVecJump.y(),
        //           -this.tempVecJump.z()
        //         );
        //       }

        //       const angle = this.tempVecJump.dot(this.up);
        //       this.canJump = angle > 0.5;

        //       if (this.canJump) {
        //         return;
        //       }
        //     }
        //   }
        // }

        QueryJump() {
          let dispatcher = this.dynamicsWorld.getDispatcher();
          let numManifolds = dispatcher.getNumManifolds();

          for (let i = 0; i < numManifolds; i++) {
            let contactManifold = dispatcher.getManifoldByIndexInternal(i);
            let numContacts = contactManifold.getNumContacts();

            for (let j = 0; j < numContacts; j++) {
              let contactPoint = contactManifold.getContactPoint(j);
              let distance = contactPoint.getDistance();

              if (distance < 0.1) {
                this.canJump = true;
                return;
              }

              // console.log({
              //   manifoldIndex: i,
              //   contactIndex: j,
              //   distance: distance,
              // });
            }
          }
        }

        // querryJumpStartAmmo() {
        //   Ammo().then((Ammo) => {
        //     Ammo = Ammo;
        //     this.AmmoClone = Ammo;
        //     this.querryJumpCreateAmmo(Ammo);
        //   });
        // }
        //
        // querryJumpCreateAmmo() {
        //   this.QueryJump(Ammo);
        // }

        updatePhysics(timeElapsed) {
          this.dynamicsWorld.stepSimulation(timeElapsed, 10);

          for (let i = 0; i < this.rigidBodies.length; i++) {
            let threeObject = this.rigidBodies[i];
            // console.log(i);
            // console.log(threeObject);
            let ammoObject = threeObject.userData.physicsBody;
            let ms = ammoObject.getMotionState();

            if (ms) {
              ms.getWorldTransform(this.TempTransform);
              let pos = this.TempTransform.getOrigin();
              let quat = this.TempTransform.getRotation();
              threeObject.position.set(pos.x(), pos.y(), pos.z());
              //threeObject.quaternion.set(quat.x(), this.playerRotation, quat.z(), quat.w());
              threeObject.quaternion.x = quat.x();
              threeObject.quaternion.z = quat.z();
              //threeObject.quaternion.w = quat.w();
              //console.log(quat.y());
              //if (this.seeAtRight) {
              //  threeObject.quaternion.set(
              //    quat.x(),
              //    quat.y() * -1,
              //    quat.z(),
              //    quat.w()
              //  );
              //} else {
              //  threeObject.quaternion.set(
              //    quat.x(),
              //    quat.y(),
              //    quat.z(),
              //    quat.w()
              //  );
              //}
            }
            //let angVel = this.player.userData.physicsBody.getAngularVelocity();
            //this.player.userData.physicsBody.setAngularVelocity(
            //  new Ammo.btVector3(angVel.x, angVel.y, angVel.z)
            //);
            this.QueryJump();
          }
        }

        movePlayer() {
          if (!this.player) return;
          if (!this.player?.userData) return;
          if (!this.player.userData?.physicsBody) return;
          //if (this.player?.position?.x)
          //this.playerCurrentPosition = this.player.position
          if (!this.playerLastPosition)
            this.playerLastPosition.copy(this.player.position);
          if (
            this.playerLastPosition.x != this.player.position.x ||
            this.playerLastPosition.y != this.player.position.y ||
            this.playerLastPosition.z != this.player.position.z
          ) {
            //console.log("ee");
            this.socket.emit("pos", this.player.position.toArray());
          } else {
            //console.log("ff");
          }
          this.moveDir = new THREE.Vector3();
          const forwardFactor =
            this._keys.moveBackward - this._keys.moveForward ||
            this.moveForwardJoystick ||
            0;
          const rightFactor =
            this._keys.moveRight - this._keys.moveLeft ||
            this.moveRightJoystick ||
            0;
          //const direction = this.moveDir
          //  .set(rightFactor, 0.0, forwardFactor)
          //  .normalize();
          //const direction = this.player.getWorldDirection(this.moveDir)
          //var direction = new THREE.Vector3( 0, 0, -1 ).applyQuaternion( this.player.quaternion );
          //console.log(direction);

          const velocity = this.player.userData.physicsBody.getLinearVelocity();

          if (this.jump && this.canJump) {
            //this.setAction(this.animationActions["jump"]);
            velocity.setY(15);
            this.canJump = false;
          }

          // if (rightFactor != 0 || forwardFactor != 0) {
          //   this.socket.emit("pos", this.player.position.toArray());
          // }

          if (rightFactor != 0 || forwardFactor != 0) {
            //console.log("e");
            //this.player.rotation.y = Math.atan2(velocity.z(), velocity.x());
            //this.player.rotation.y += Math.PI / 2;
            this.setAction(this.animationActions["run"]);
          } else {
            this.setAction(this.animationActions["idle"]);
          }

          // if(Input.GetKeyDown('Space') && this.physicsComponent.canJump){
          //     velocity.setY(this.jumpVelocity);
          //     this.physicsComponent.canJump = false;
          // }

          //this.Deccelerate(t);
          //this.Accelarate(direction, t);

          const moveVector = this.tempVec.copy(
            new THREE.Vector3(rightFactor, 0, forwardFactor)
          );

          velocity.setX(moveVector.x * 5);
          velocity.setZ(moveVector.z * 5);

          //if (rightFactor != 0 || forwardFactor != 0) {
          //this.player.rotation.set(0, 90*Math.PI/, 0);
          //this.playerRotation += 0.01
          //console.log(this.playerRotation);
          //-1 left
          //+1 right
          //0.7 bottom right
          //console.log(direction);
          //console.log(this.player.userData.physicsBody.getAngularVelocity());
          ///console.log(this.player.quaternion);
          //const quaternion = new THREE.Quaternion();
          //quaternion = new Ammo.btVector3(rightFactor, 0, forwardFactor);
          //console.log(quaternion.y());
          //console.log(new Ammo.btVector3(rightFactor, 0, forwardFactor));
          // let q = this.player.quaternion.copy().inverse();
          //velocity.applyQuaternion(quaternion);
          //let angVel = this.player.userData.physicsBody.getAngularVelocity();
          //console.log(angVel.y());
          //this.player.userData.physicsBody.setAngularVelocity(
          //  new Ammo.btVector3(0, -1, 0)
          //);
          //} else {
          //  this.playerRotation = 0;
          //}

          //let directionX = rightFactor * 90;
          //if (forwardFactor == -1) {
          //  let directionZ = 180;
          //} else if (forwardFactor == 1) {
          //  let directionZ = 0;
          //}
          //directionX = (rightFactor * Math.PI) / 180;
          //directionZ = (forwardFactor * Math.PI) / 180
          if (this.rotationCanvasEnable) {
            this.player.rotation.set(0, this.rotationCanvas, 0);
          } else {
            if (rightFactor == 1) {
              if (forwardFactor == 1) {
                this.player.rotation.set(0, Math.PI / (135 / 45), 0);
              } else if (forwardFactor == -1) {
                this.player.rotation.set(0, Math.PI / 1.5, 0);
              } else {
                this.player.rotation.set(0, Math.PI / (90 / 45), 0);
              }
            } else if (rightFactor == -1) {
              if (forwardFactor == 1) {
                this.player.rotation.set(0, Math.PI / (-135 / 45), 0);
              } else if (forwardFactor == -1) {
                this.player.rotation.set(0, Math.PI / -1.5, 0);
              } else {
                this.player.rotation.set(0, Math.PI / (-90 / 45), 0);
              }
            } else if (forwardFactor == -1) {
              this.player.rotation.set(0, Math.PI, 0);
            } else if (forwardFactor == 1) {
              this.player.rotation.set(0, 0, 0);
            }
          }

          //this.player.lookAt(direction)
          //if (forwardFactor == 1) {
          //  if (rightFactor == 1) {
          //    this.player.rotation.set(0, Math.PI / (-135 / 45), 0);
          //  } else if (rightFactor == -1) {
          //    this.player.rotation.set(0, Math.PI / (45 / 45), 0);
          //  }
          //} else if (forwardFactor == -1) {
          //  if (rightFactor == 1) {
          //    this.player.rotation.set(0, Math.PI / (-135 / 45), 0);
          //  } else if (rightFactor == -1) {
          //    this.player.rotation.set(0, Math.PI / (-45 / 45), 0);
          //  }
          //}

          // console.log(this.playerObject.userData.physicsBody);
          //switch (rightFactor) {
          //  case -1:
          //    this.player.rotation.set(0, Math.PI / (-90 / 45), 0);
          //    break;
          //
          //  case 1:
          //    this.player.rotation.set(0, Math.PI / (90 / 45), 0);
          //    break;
          //}
          //switch (forwardFactor) {
          //  case -1:
          //    this.player.rotation.set(0, Math.PI / (-180 / 45), 0);
          //    break;
          //
          //  case 1:
          //    this.player.rotation.set(0, Math.PI / (180 / 45), 0);
          //    break;
          //}

          this.player.userData.physicsBody.setLinearVelocity(velocity);
          //let playerPosition = this.playerObject.position;

          //this.camera.position.set(
          //  playerPosition.x,
          //  playerPosition.y + 20,
          //  playerPosition.z + 40
          //);
          //this.camera.lookAt(this.playerObject.position);

          //this.player.userData.physicsBody.setAngularVelocity(quaternion);

          // const ms = this.playerObject.userData.physicsBody.getMotionState();
          // if (ms) {
          //   ms.getWorldTransform(this.transform);
          //   const p = this.TempTransform.getOrigin();
          //   this.player.position.set(p.x(), p.y() + this.yOffset, p.z());
          //   this.player.rotation.set(0, -90, 0);
          //   // this.camera.position.set(p.x(), p.y() + this.yOffset, p.z());
          //   // this.parent.SetPosition(this.camera.position);
          // }
          this.playerLastPosition.copy(this.player.position);
        }

        // action(action) {
        //   switch (action) {
        //     case "idle":
        //       this.setAction(this.animationActions[1]);
        //       break;
        //     case "run":
        //       this.setAction(this.animationActions[2]);
        //       break;
        //     case "jump":
        //       this.setAction(this.animationActions[3]);
        //       break;
        //     case "fall":
        //       this.setAction(this.animationActions[4]);
        //       break;
        //     case "die":
        //       this.setAction(this.animationActions[5]);
        //       break;
        //     case "attack":
        //       this.setAction(this.animationActions[6]);
        //       break;
        //     case "hit":
        //       this.setAction(this.animationActions[7]);
        //       break;
        //     case "dead":
        //       this.setAction(this.animationActions[8]);
        //       break;
        //     // default:
        //     //   this.setAction(this.animationActions[1]);
        //     //   break;
        //   }
        // }

        thirdPersonCameraUpdate(timeElapsed) {
          if (!this.player) return;
          const playerPosition = this.player.position;

          const idealOffset = new THREE.Vector3(0, 30, 40);
          idealOffset.add(this.player.position);
          const idealLookat = new THREE.Vector3(0, 0, 0);
          idealLookat.add(this.player.position);

          // const t = 0.05;
          // const t = 4.0 * timeElapsed;
          const t = 1.0 - Math.pow(0.001, timeElapsed);

          this.currentPosition.lerp(idealOffset, t);
          this.currentLookat.lerp(idealLookat, t);

          this.camera.position.copy(this.currentPosition);
          this.camera.lookAt(this.currentLookat);

          //this.camera.position.set(
          //  playerPosition.x,
          //  playerPosition.y + 20,
          //  playerPosition.z + 40
          //);
        }

        //update = () => {
        //  //const currentFrame = this.scene.time.now
        //  //if (this.previousFrame==null) {
        //  //  this.previousFrame = currentFrame
        //  //}
        //
        //  //if (!this.modelReady) return;
        //  this.renderer.render(this.scene, this.camera);
        //  // requestAnimationFrame(() => this.update());
        //  this.delta = this.clock.getDelta() * 2;
        //
        //  //let timeElapsed = currentFrame -this.previousFrame
        //  let timeElapsed = this.clock.getElapsedTime();
        //  const timeElapsedS = timeElapsed * 0.001;
        //
        //  if (this.modelReady) {
        //    this.mixer.update(timeElapsed);
        //  }
        //  //console.log(this.player.position);
        //
        //  this.thirdPersonCameraUpdate(timeElapsed);
        //  this.movePlayer();
        //
        //  if (this.playerBB)
        //    this.playerBB
        //      .copy(this.player.geometry.boundingBox)
        //      .applyMatrix4(this.player.matrixWorld);
        //
        //  // this.updateMovement();
        //  // this.updateJump();
        //
        //  if (this.dynamicsWorld) this.updatePhysics(timeElapsed);
        //
        //  //if (this.mixer) {
        //  //  // console.log(this.mixer.time);
        //  //  this.mixer.update(timeElapsedS);
        //  //}
        //  this.animFrameId = window.requestAnimationFrame(this.update);
        //};

        canvasSetUp() {
          this.canvas = document.getElementById("joystick");
          this.ctx = this.canvas.getContext("2d");
          this.canvasResize();

          document.addEventListener("mousedown", (e) => this.startDrawing(e));
          document.addEventListener("mouseup", () => this.stopDrawing());
          document.addEventListener("mousemove", (e) => this.Draw(e));

          document.addEventListener("touchstart", (e) => this.startDrawing(e));
          document.addEventListener("touchend", () => this.stopDrawing());
          document.addEventListener("touchcancel", () => this.stopDrawing());
          document.addEventListener("touchmove", (e) => this.Draw(e));
          window.addEventListener("resize", () => this.canvasResize());

          this.coord = { x: 0, y: 0 };
          this.paint = false;
        }
        is_it_in_the_circle() {
          var current_radius = Math.sqrt(
            Math.pow(this.coord.x - this.x_orig, 2) +
              Math.pow(this.coord.y - this.y_orig, 2)
          );
          if (this.radius >= current_radius) return true;
          else return false;
        }
        getPosition(event) {
          var mouse_x = event?.clientX || event?.touches?.[0].clientX;
          var mouse_y = event?.clientY || event?.touches[0].clientY;
          this.coord.x = mouse_x - this.canvas.offsetLeft;
          this.coord.y = mouse_y - this.canvas.offsetTop;
        }
        joystick(width, height) {
          this.ctx.beginPath();
          this.ctx.arc(width, height, this.radius / 2, 0, Math.PI * 2, true);
          this.ctx.fillStyle = "#F08080";
          this.ctx.fill();
          this.ctx.strokeStyle = "#F6ABAB";
          this.ctx.lineWidth = 8;
          this.ctx.stroke();
        }
        Draw(event) {
          if (this.paint) {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.background();
            var angle_in_degrees, x, y, speed;
            var angle = Math.atan2(
              this.coord.y - this.y_orig,
              this.coord.x - this.x_orig
            );

            if (Math.sign(angle) == -1) {
              angle_in_degrees = Math.round((-angle * 180) / Math.PI);
            } else {
              angle_in_degrees = Math.round(360 - (angle * 180) / Math.PI);
            }

            if (this.is_it_in_the_circle()) {
              this.joystick(this.coord.x, this.coord.y);
              x = this.coord.x;
              y = this.coord.y;
            } else {
              x = this.radius * Math.cos(angle) + this.x_orig;
              y = this.radius * Math.sin(angle) + this.y_orig;
              this.joystick(x, y);
            }

            this.getPosition(event);

            var speed = Math.round(
              (100 *
                Math.sqrt(
                  Math.pow(x - this.x_orig, 2) + Math.pow(y - this.y_orig, 2)
                )) /
                this.radius
            );

            var x_relative = Math.round(x - this.x_orig);
            var y_relative = Math.round(y - this.y_orig);
            this.moveForwardJoystick = y_relative / 50;
            this.moveRightJoystick = x_relative / 50;
            this.rotationCanvasEnable = true;
            this.rotationCanvas = (angle_in_degrees + 90) * (Math.PI / 180);
            //send(x_relative, y_relative, speed, angle_in_degrees);
          }
        }
        stopDrawing() {
          this.paint = false;
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          this.background();
          this.joystick(this.width / 2, this.height / 2);
          this.moveForwardJoystick = 0;
          this.moveRightJoystick = 0;
          this.rotationCanvasEnable = false;
        }
        startDrawing(event) {
          this.paint = true;
          this.getPosition(event);
          if (this.is_it_in_the_circle()) {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.background();
            this.joystick(this.coord.x, this.coord.y);
            this.Draw();
          }
        }
        background() {
          this.x_orig = this.width / 2;
          this.y_orig = this.height / 2;

          this.ctx.beginPath();
          this.ctx.arc(
            this.x_orig,
            this.y_orig,
            this.radius * 1.5,
            0,
            Math.PI * 2,
            true
          );
          this.ctx.fillStyle = "#ECE5E5";
          this.ctx.fill();
        }
        canvasResize() {
          this.radius = 50;
          //width = window.innerWidth
          this.width = this.radius * 3.25;
          this.height = this.radius * 3.25;
          this.ctx.canvas.width = this.width;
          this.ctx.canvas.height = this.height;
          this.background();
          this.joystick(this.width / 2, this.height / 2);
        }

        update() {
          //const currentFrame = this.scene.time.now
          window.requestAnimationFrame((t) => {
            if (!this.previousFrame) {
              this.previousFrame = t;
            }
            this.step(t);
            this.renderer.render(this.scene, this.camera);

            this.previousFrame = t;
            this.update();
            //if (this.mixer) {
            //  // console.log(this.mixer.time);
            //  this.mixer.update(timeElapsedS);
            //}
          });
        }

        step(t) {
          if (this.mixer && this.modelReady && this.player && this.loading) {
            this.loading = false;
            document.querySelector(".loadingScreen").style.visibility =
              "hidden";
            if (window.mobileAndTabletCheck()) {
              document.querySelector(".joystick").style.visibility = "visible";
              this.canvasSetUp();
            }
          }

          //if (!this.modelReady) return;
          // requestAnimationFrame(() => this.update());
          this.delta = this.clock.getDelta();

          let timeElapsed = t - this.previousFrame;
          //let timeElapsed = this.clock.getElapsedTime();
          const timeElapsedS = timeElapsed * 0.001;

          if (this.mixer && this.modelReady && this.player) {
            //this.animationActions[0].play()
            //console.log(this.villagers["1.1"]);
            //this.villagerActions[0].play();
            this.mixer.update(this.delta);
            //this.mixer.update(this.delta);
          }
          //console.log(this.player.position);

          this.thirdPersonCameraUpdate(timeElapsed);
          this.movePlayer();
          this.playersAnim.update();
          //this.moveVillagers();
          this.Villagers.update();
          //console.log(this.player.boundingBox);

          //if (this.playerBB)
          //  this.playerBB
          //  .applyMatrix4(this.player.matrixWorld);
          //.copy(this.player.geometry.boundingBox)

          // this.updateMovement();
          // this.updateJump();

          if (this.dynamicsWorld) this.updatePhysics(timeElapsed);
        }
      }

      window.addEventListener("DOMContentLoaded", () => {
        window.mobileAndTabletCheck = function () {
          let check = false;
          (function (a) {
            if (
              /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(
                a
              ) ||
              /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(
                a.substr(0, 4)
              )
            )
              check = true;
          })(navigator.userAgent || navigator.vendor || window.opera);
          return check;
        };
        console.log(window.mobileAndTabletCheck());
        Ammo().then((lib) => {
          Ammo = lib;
          let app = new App();
        });
      });
    </script>
  </head>
  <body>
    <script></script>
    <div id="info"></div>
    <div id="gridSelector">
      <button id="showBuildMenu">Build Menu</button>
      <button id="showCollectMenu">Collect Menu</button>
      <div id="buildMenu">
        <button id="buildHouse">
          <img src="/img/house.png" width="80px" />
          <p class="buildable">
            50<img src="/img/wood.png" width="30px" /> Build House
          </p>
        </button>
        <button id="buildMine">
          <img src="/img/mine.png" width="80px" />
          <p class="buildable">
            50<img src="/img/andesite.png" width="30px" /> Build Mine
          </p>
        </button>
        <button id="buildBlacksmithHouse">
          <img src="/img/blacksmith_house.png" width="80px" />
          <p class="buildable">
            50<img src="/img/andesite.png" width="30px" /> Build Blacksmith
            House
          </p>
        </button>
        <button id="buildShop">
          <img src="/img/shop-icon.png" width="80px" />
          <p class="buildable">
            50<img src="/img/andesite.png" width="30px" /> Build Shop
          </p>
        </button>
      </div>
      <div id="collectMenu">
        <p id="noVillagerText">
          You don't have esclaves. <br />You can build a house
        </p>
      </div>
    </div>
    <div id="resources">
      <div id="wood">
        <label for="">WOOD</label>
        <img src="/img/wood.png" width="50" height="50" />
        <label for="" id="woodCount">500</label>
      </div>
      <div id="stone">
        <label for="">STONE</label>
        <img src="/img/andesite.png" width="50" height="50" />
        <label for="" id="stoneCount">500</label>
      </div>
      <div id="iron">
        <label for="">IRON</label>
        <img src="/img/Iron_Ingot.png" width="50" height="50" />
        <label for="" id="ironCount">0</label>
      </div>
      <div id="coal">
        <label for="">COAL</label>
        <img src="/img/Coal.png" width="50" height="50" />
        <label for="" id="coalCount">0</label>
      </div>
    </div>
    <div id="error"></div>
    <div id="menu">
      <h1>The World of Capitalists</h1>
      <h2>Discover, Build and Fight</h2>
      <button id="start_game">Jump in the World</button>
    </div>
    <div id="selectMenu">
      <h1 class="joinParty">Join Party</h1>
      <div id="partyList">Party</div>
      <div class="createParty">
        <!--<button id="createParty" class="startGame">Create your party</button>-->
        <button
          type="button"
          class="btn btn-primary"
          data-bs-toggle="modal"
          data-bs-target="#exampleModal"
          data-bs-whatever="@getbootstrap"
        >
          Create Party
        </button>

        <div
          class="modal fade"
          id="exampleModal"
          tabindex="-1"
          aria-labelledby="exampleModalLabel"
          aria-hidden="true"
        >
          <div class="modal-dialog">
            <div class="modal-content">
              <div class="modal-header">
                <h5 class="modal-title" id="exampleModalLabel">New Party</h5>
                <button
                  type="button"
                  class="btn-close"
                  data-bs-dismiss="modal"
                  aria-label="Close"
                ></button>
              </div>
              <div class="modal-body">
                <form>
                  <div class="form-group">
                    <label for="recipient-name" class="col-form-label"
                      >Party Name</label
                    >
                    <input
                      type="text"
                      class="form-control"
                      id="recipient-name"
                    />
                  </div>
                  <div class="form-group">
                    <label for="recipient-seed" class="col-form-label"
                      >Seed</label
                    >
                    <input
                      type="text"
                      class="form-control"
                      id="recipient-seed"
                      placeholder="69"
                    />
                  </div>
                  <div class="form-row">
                    <div class="form-group col-md-6">
                      <label for="recipient-size-x">Map size X:</label>
                      <input
                        placeholder="20"
                        type="number"
                        class="form-control"
                        id="recipient-size-x"
                      />
                    </div>
                    <div class="form-group col-md-6">
                      <label for="recipient-size-z">Map size Z:</label>
                      <input
                        placeholder="20"
                        type="number"
                        class="form-control"
                        id="recipient-size-z"
                      />
                    </div>
                  </div>
                </form>
              </div>
              <div class="modal-footer">
                <button
                  type="button"
                  class="btn btn-secondary"
                  data-bs-dismiss="modal"
                >
                  Close
                </button>
                <button
                  type="button"
                  class="btn btn-primary startGame"
                  data-bs-dismiss="modal"
                >
                  Create Party
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="loadingScreen">
      <img
        src="/img/Ecran_de_chargement.jpg"
        id="loadingScreen"
        alt=""
        srcset=""
      />
      <p>Loading...</p>
    </div>
    <div class="joystick">
      <canvas id="joystick" name="game"></canvas>
    </div>
    <div id="three"></div>
  </body>
</html>
